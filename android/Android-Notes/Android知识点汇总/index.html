<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>Android知识点汇总 - koala</title>
        <link href="../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../..">koala</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../../.." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../log/" class="nav-link">Log</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Java <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../Java/Java%E6%B5%81/" class="dropdown-item">Java流</a>
</li>
                                    
<li>
    <a href="../../../Java/Java%E7%BC%96%E7%A0%81/" class="dropdown-item">Java编码</a>
</li>
                                    
<li>
    <a href="../../../Java/LocalDateTime%E5%A4%84%E7%90%86/" class="dropdown-item">LocalDateTime处理</a>
</li>
                                    
<li>
    <a href="../../../Java/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/" class="dropdown-item">参考文档</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">加密算法</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../Java/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/%E5%85%A5%E9%97%A8/" class="dropdown-item">入门</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">多线程</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-notion/" class="dropdown-item">并发编程 notion</a>
</li>
            
<li>
    <a href="../../../Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="dropdown-item">并发编程</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">PC端 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../PC%E7%AB%AF/electron/" class="dropdown-item">Electron</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Android <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../android%20%E4%BB%BB%E5%8A%A1%E5%AE%8C%E6%88%90%E5%BA%A6/" class="dropdown-item">Android 任务完成度</a>
</li>
                                    
<li>
    <a href="../../%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/" class="dropdown-item">代码模板</a>
</li>
                                    
<li>
    <a href="../../%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/" class="dropdown-item">参考文档</a>
</li>
                                    
<li>
    <a href="../../%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" class="dropdown-item">学习计划</a>
</li>
                                    
<li>
    <a href="../../%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="dropdown-item">学习记录</a>
</li>
                                    
<li>
    <a href="../../%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0/" class="dropdown-item">项目实战学习</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Android 系列博客</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Android%20%E7%B3%BB%E5%88%97%E5%8D%9A%E5%AE%A2/Android%20Service/" class="dropdown-item">Android Service</a>
</li>
            
<li>
    <a href="../../Android%20%E7%B3%BB%E5%88%97%E5%8D%9A%E5%AE%A2/Android%20fragment/" class="dropdown-item">Android fragment</a>
</li>
            
<li>
    <a href="../../Android%20%E7%B3%BB%E5%88%97%E5%8D%9A%E5%AE%A2/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/" class="dropdown-item">Android 事件分发机制</a>
</li>
            
<li>
    <a href="../../Android%20%E7%B3%BB%E5%88%97%E5%8D%9A%E5%AE%A2/%E5%AE%89%E5%8D%93%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" class="dropdown-item">安卓线程模型</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Android Notes</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../Android%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="dropdown-item">Android开源库源码分析</a>
</li>
            
<li>
    <a href="../Android%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9/" class="dropdown-item">Android扩展知识点</a>
</li>
            
<li>
    <a href="./" class="dropdown-item active">Android知识点汇总</a>
</li>
            
<li>
    <a href="../C%2B%2B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="dropdown-item">C++知识点汇总</a>
</li>
            
<li>
    <a href="../Framework%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="dropdown-item">Framework知识点汇总</a>
</li>
            
<li>
    <a href="../Gradle%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="dropdown-item">依赖项配置</a>
</li>
            
<li>
    <a href="../Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="dropdown-item">Java知识点汇总</a>
</li>
            
<li>
    <a href="../Kotlin%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="dropdown-item">Kotlin知识点汇总</a>
</li>
            
<li>
    <a href="../%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB/" class="dropdown-item">常见面试算法题汇总</a>
</li>
            
<li>
    <a href="../%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="dropdown-item">性能优化知识点汇总</a>
</li>
            
<li>
    <a href="../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" class="dropdown-item">计算机网络基础</a>
</li>
            
<li>
    <a href="../%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B1%87%E6%80%BB/" class="dropdown-item">设计模式汇总</a>
</li>
            
<li>
    <a href="../%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="dropdown-item">音视频知识点汇总</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Android framework</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../android%20framework/%E5%AD%A6%E4%B9%A0%E5%87%86%E5%88%99/" class="dropdown-item">学习准则</a>
</li>
            
<li>
    <a href="../../android%20framework/%E6%9D%82%E4%B9%B1%E7%AC%94%E8%AE%B0/" class="dropdown-item">杂乱笔记</a>
</li>
            
<li>
    <a href="../../android%20framework/%E6%9E%B6%E6%9E%84/" class="dropdown-item">架构</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Liunx <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../liunx/git%20%E5%91%BD%E4%BB%A4/" class="dropdown-item">Git 命令</a>
</li>
                                    
<li>
    <a href="../../../liunx/jenkins/" class="dropdown-item">Jenkins</a>
</li>
                                    
<li>
    <a href="../../../liunx/yum%20%E5%91%BD%E4%BB%A4/" class="dropdown-item">Yum 命令</a>
</li>
                                    
<li>
    <a href="../../../liunx/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="dropdown-item">常用命令</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Python <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../python/QT5/" class="dropdown-item">QT5</a>
</li>
                                    
<li>
    <a href="../../../python/numpy/" class="dropdown-item">Numpy</a>
</li>
                                    
<li>
    <a href="../../../python/turtle/" class="dropdown-item">Turtle</a>
</li>
                                    
<li>
    <a href="../../../python/%E6%95%A3%E4%B9%B1%E7%9F%A5%E8%AF%86/" class="dropdown-item">散乱知识</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Socket <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../socket/socket%20%E8%8D%89%E7%A8%BF/" class="dropdown-item">Socket 草稿</a>
</li>
                                    
<li>
    <a href="../../../socket/socket%20%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E6%91%98%E8%A6%81/" class="dropdown-item">Socket 重要概念摘要</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Srping 系列 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Security</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/security/Oauth2%20%E5%9B%9B%E7%A7%8D%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F/" class="dropdown-item">Oauth2 四种授权模式</a>
</li>
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/security/Q%26A/" class="dropdown-item">Q&A</a>
</li>
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/security/demo%20%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0/" class="dropdown-item">Demo 项目搭建学习</a>
</li>
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/security/token%20%E7%B3%BB%E5%88%97%E7%9F%A5%E8%AF%86/" class="dropdown-item">Token 系列知识</a>
</li>
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/security/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/" class="dropdown-item">参考文档</a>
</li>
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/security/%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="dropdown-item">授权服务器配置</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">详解</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/security/%E8%AF%A6%E8%A7%A3/TokenStore/" class="dropdown-item">TokenStore</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">开发问题详解</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/mybatis-plus/" class="dropdown-item">Mybatis plus</a>
</li>
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/sql%E8%AF%AD%E5%8F%A5/" class="dropdown-item">Sql语句</a>
</li>
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/%E4%BC%A0%E5%8F%82%E6%95%B0/" class="dropdown-item">传参数</a>
</li>
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/" class="dropdown-item">切面编程</a>
</li>
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/%E5%8F%82%E6%95%B0%E6%95%88%E9%AA%8C/" class="dropdown-item">参数效验</a>
</li>
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/%E5%BC%80%E5%8F%91%E6%A6%82%E5%8F%99/" class="dropdown-item">开发概叙</a>
</li>
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F/" class="dropdown-item">开发注意</a>
</li>
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/%E6%95%88%E9%AA%8C/" class="dropdown-item">效验</a>
</li>
            
<li>
    <a href="../../../srping%20%E7%B3%BB%E5%88%97/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/%E8%A7%84%E8%8C%83%E9%97%AE%E9%A2%98/" class="dropdown-item">规范问题</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">中间件 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Es</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../%E4%B8%AD%E9%97%B4%E4%BB%B6/es/ElasticSearch%207.14/" class="dropdown-item">ElasticSearch 7.14-分布式搜索引擎</a>
</li>
            
<li>
    <a href="../../../%E4%B8%AD%E9%97%B4%E4%BB%B6/es/es/" class="dropdown-item">Es</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Nacos</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../%E4%B8%AD%E9%97%B4%E4%BB%B6/nacos/KubeSphere%20%E9%83%A8%E7%BD%B2%20nacos/" class="dropdown-item">KubeSphere 部署 nacos</a>
</li>
            
<li>
    <a href="../../../%E4%B8%AD%E9%97%B4%E4%BB%B6/nacos/nacos%E5%91%BD%E4%BB%A4/" class="dropdown-item">Nacos命令</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">消息队列</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ%E5%85%A8%E6%99%AF%E5%9B%BE/" class="dropdown-item">RocketMQ全景图</a>
</li>
            
<li>
    <a href="../../../%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rocketMQ%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="dropdown-item">rocketMQ 官方文档阅读笔记</a>
</li>
            
<li>
    <a href="../../../%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rocketmq%20%E5%9F%BA%E6%9C%AC%E6%A0%B7%E4%BE%8B/" class="dropdown-item">Rocketmq 基本样例</a>
</li>
            
<li>
    <a href="../../../%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rocketmq%20%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BD%BF%E7%94%A8/" class="dropdown-item">Rocketmq 控制台使用</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">云原生 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../%E4%BA%91%E5%8E%9F%E7%94%9F/kubemetes%E5%91%BD%E4%BB%A4/" class="dropdown-item">Kubemetes命令</a>
</li>
                                    
<li>
    <a href="../../../%E4%BA%91%E5%8E%9F%E7%94%9F/kubesphere/" class="dropdown-item">Kubesphere</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">DevOps</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../%E4%BA%91%E5%8E%9F%E7%94%9F/DevOps/DevOps/" class="dropdown-item">DevOps</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Docker</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../%E4%BA%91%E5%8E%9F%E7%94%9F/docker/docker%20%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" class="dropdown-item">Docker 命令大全</a>
</li>
            
<li>
    <a href="../../../%E4%BA%91%E5%8E%9F%E7%94%9F/docker/docker%20%E6%A1%88%E4%BE%8B/" class="dropdown-item">Docker 案例</a>
</li>
            
<li>
    <a href="../../../%E4%BA%91%E5%8E%9F%E7%94%9F/docker/k8s%E5%91%BD%E4%BB%A4/" class="dropdown-item">K8s命令</a>
</li>
            
<li>
    <a href="../../../%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E9%97%AE%E9%A2%98/" class="dropdown-item">问题</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">开发常见问题 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/mybatis%20%E7%BC%96%E5%86%99/" class="dropdown-item">Mybatis 编写</a>
</li>
                                    
<li>
    <a href="../../../%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%AE%9E%E4%BD%93%E7%B1%BB/" class="dropdown-item">实体类</a>
</li>
                                    
<li>
    <a href="../../../%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89/" class="dropdown-item">数据库定义</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">解决方案</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E9%99%90%E5%88%B6%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%A7%E5%B0%8F/" class="dropdown-item">限制文件上传大小</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">开源项目 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E5%8F%82%E4%B8%8E%E5%BC%80%E6%BA%90/" class="dropdown-item">参与开源</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">微服务 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../%E5%BE%AE%E6%9C%8D%E5%8A%A1/K8S%20%E5%85%A5%E9%97%A8/" class="dropdown-item">K8S 入门</a>
</li>
                                    
<li>
    <a href="../../../%E5%BE%AE%E6%9C%8D%E5%8A%A1/NACOS%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="dropdown-item">NACOS 基础知识</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Spring cloud</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../%E5%BE%AE%E6%9C%8D%E5%8A%A1/spring-cloud/spring-cloud%20%E5%AD%A6%E4%B9%A0/" class="dropdown-item">Spring cloud 学习</a>
</li>
            
<li>
    <a href="../../../%E5%BE%AE%E6%9C%8D%E5%8A%A1/spring-cloud/%E7%BD%91%E5%85%B3/" class="dropdown-item">网关</a>
</li>
            
<li>
    <a href="../../../%E5%BE%AE%E6%9C%8D%E5%8A%A1/spring-cloud/%E7%BD%91%E5%85%B3%E9%9B%86%E6%88%90Oauth2%E8%AF%A6%E8%A7%A3/" class="dropdown-item">网关集成Oauth2详解</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">数据库 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Mybatis</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/mybatis%20%E5%85%A8%E8%A7%A3/" class="dropdown-item">使用案例</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Mybatis plus</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis-plus/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E8%AF%A6%E8%A7%A3/" class="dropdown-item">官方文档详解</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Mysql</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="dropdown-item">Mysql 常用命令</a>
</li>
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%20%E7%B4%A2%E5%BC%95%E7%AF%87/" class="dropdown-item">Mysql 索引篇</a>
</li>
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%B2%97%E8%AF%BB/" class="dropdown-item">Mysql官方文档粗读</a>
</li>
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%BC%96%E7%A8%8B/" class="dropdown-item">Mysql编程</a>
</li>
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E8%AF%A6%E8%A7%A3/" class="dropdown-item">Mysql详解</a>
</li>
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/" class="dropdown-item">Mysql问题大全</a>
</li>
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/readme/" class="dropdown-item">Readme</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Mysql45讲</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql45%E8%AE%B2/Info/" class="dropdown-item">Info</a>
</li>
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql45%E8%AE%B2/%E6%97%A5%E5%BF%97/" class="dropdown-item">日志</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Redis</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%20%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3/" class="dropdown-item">Redis 基础文档</a>
</li>
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/" class="dropdown-item">Redis 官方文档笔记</a>
</li>
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%8E%9F%E7%94%9F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/" class="dropdown-item">原生分布式锁实现方式</a>
</li>
            
<li>
    <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="dropdown-item">常见问题</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">社招面试 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../%E7%A4%BE%E6%8B%9B%E9%9D%A2%E8%AF%95/%E5%8F%82%E8%80%83/" class="dropdown-item">参考</a>
</li>
                                    
<li>
    <a href="../../../%E7%A4%BE%E6%8B%9B%E9%9D%A2%E8%AF%95/%E6%9D%82%E9%A1%B9/" class="dropdown-item">杂项</a>
</li>
                                    
<li>
    <a href="../../../%E7%A4%BE%E6%8B%9B%E9%9D%A2%E8%AF%95/%E9%A9%AC%E5%A3%AB%E5%85%B5%E9%9D%A2%E8%AF%95%E8%A7%86%E9%A2%912023/" class="dropdown-item">马士兵面试视频2023</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">设计模式 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/" class="dropdown-item">模板模式</a>
</li>
                                    
<li>
    <a href="../../../%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="dropdown-item">观察者模式</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../Android%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../C%2B%2B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#activity" class="nav-link">Activity</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_1" class="nav-link">生命周期</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_2" class="nav-link">启动模式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_3" class="nav-link">启动过程</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#fragment" class="nav-link">Fragment</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_4" class="nav-link">特点</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_5" class="nav-link">生命周期</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#activity_1" class="nav-link">与Activity通信</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#service" class="nav-link">Service</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_6" class="nav-link">启动过程</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_7" class="nav-link">绑定过程</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_8" class="nav-link">生命周期</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_9" class="nav-link">启用前台服务</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#broadcastreceiver" class="nav-link">BroadcastReceiver</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_10" class="nav-link">注册过程</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#contentprovider" class="nav-link">ContentProvider</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_11" class="nav-link">基本使用</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#_12" class="nav-link">数据存储</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#view" class="nav-link">View</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#measurespec" class="nav-link">MeasureSpec</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#motionevent" class="nav-link">MotionEvent</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#velocitytracker" class="nav-link">VelocityTracker</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#gesturedetector" class="nav-link">GestureDetector</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#scroller" class="nav-link">Scroller</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#view_1" class="nav-link">View 的滑动</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#view_2" class="nav-link">View 的事件分发</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#activity-view" class="nav-link">在 Activity 中获取某个 View 的宽高</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#draw" class="nav-link">Draw 的基本流程</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#view_3" class="nav-link">自定义 View</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#_13" class="nav-link">进程</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_14" class="nav-link">进程生命周期</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_15" class="nav-link">多进程</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_16" class="nav-link">进程存活</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#parcelable" class="nav-link">Parcelable 接口</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_19" class="nav-link">使用示例</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_20" class="nav-link">方法说明</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#parcelable-serializable" class="nav-link">Parcelable 与 Serializable 对比</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#ipc" class="nav-link">IPC</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#ipc_1" class="nav-link">IPC方式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#binder" class="nav-link">Binder</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#aidl" class="nav-link">AIDL 通信</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#messenger" class="nav-link">Messenger</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#window-windowmanager" class="nav-link">Window / WindowManager</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#window" class="nav-link">Window 概念与分类</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#window_1" class="nav-link">Window 的内部机制</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#window_2" class="nav-link">Window 的创建过程</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#bitmap" class="nav-link">Bitmap</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_22" class="nav-link">配置信息与压缩方式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_23" class="nav-link">常用操作</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#bitmapfactory" class="nav-link">BitmapFactory</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_28" class="nav-link">内存回收</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#_29" class="nav-link">屏幕适配</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_30" class="nav-link">单位</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_31" class="nav-link">头条适配方案</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_32" class="nav-link">刘海屏适配</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#context" class="nav-link">Context</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#sharedpreferences" class="nav-link">SharedPreferences</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_33" class="nav-link">获取方式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_34" class="nav-link">架构</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#apply-commit" class="nav-link">apply / commit</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_35" class="nav-link">注意</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#_36" class="nav-link">消息机制</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#handler" class="nav-link">Handler 机制</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_37" class="nav-link">工作原理</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#_38" class="nav-link">线程异步</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#asynctask" class="nav-link">AsyncTask</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#handlerthread" class="nav-link">HandlerThread</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#intentservice" class="nav-link">IntentService</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_41" class="nav-link">线程池</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#recyclerview" class="nav-link">RecyclerView 优化</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#webview" class="nav-link">Webview</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_42" class="nav-link">基本使用</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#webview_2" class="nav-link">Webview 加载优化</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_43" class="nav-link">内存泄漏</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<ul>
<li><a href="#activity">Activity</a></li>
<li><a href="#生命周期">生命周期</a></li>
<li><a href="#启动模式">启动模式</a></li>
<li><a href="#启动过程">启动过程</a></li>
<li><a href="#fragment">Fragment</a></li>
<li><a href="#特点">特点</a></li>
<li><a href="#生命周期-1">生命周期</a></li>
<li><a href="#与activity通信">与Activity通信</a></li>
<li><a href="#service">Service</a></li>
<li><a href="#启动过程-1">启动过程</a></li>
<li><a href="#绑定过程">绑定过程</a></li>
<li><a href="#生命周期-2">生命周期</a></li>
<li><a href="#启用前台服务">启用前台服务</a></li>
<li><a href="#broadcastreceiver">BroadcastReceiver</a></li>
<li><a href="#注册过程">注册过程</a></li>
<li><a href="#contentprovider">ContentProvider</a></li>
<li><a href="#基本使用">基本使用</a></li>
<li><a href="#数据存储">数据存储</a></li>
<li><a href="#view">View</a></li>
<li><a href="#measurespec">MeasureSpec</a></li>
<li><a href="#motionevent">MotionEvent</a></li>
<li><a href="#velocitytracker">VelocityTracker</a></li>
<li><a href="#gesturedetector">GestureDetector</a></li>
<li><a href="#scroller">Scroller</a></li>
<li><a href="#view-的滑动">View 的滑动</a></li>
<li><a href="#view-的事件分发">View 的事件分发</a></li>
<li><a href="#在-activity-中获取某个-view-的宽高">在 Activity 中获取某个 View 的宽高</a></li>
<li><a href="#draw-的基本流程">Draw 的基本流程</a></li>
<li><a href="#自定义-view">自定义 View</a></li>
<li><a href="#进程">进程</a></li>
<li><a href="#进程生命周期">进程生命周期</a></li>
<li><a href="#多进程">多进程</a></li>
<li><a href="#进程存活">进程存活</a><ul>
<li><a href="#oom_adj">OOM_ADJ</a></li>
<li><a href="#进程被杀情况">进程被杀情况</a></li>
<li><a href="#进程保活方案">进程保活方案</a></li>
</ul>
</li>
<li><a href="#parcelable-接口">Parcelable 接口</a></li>
<li><a href="#使用示例">使用示例</a></li>
<li><a href="#方法说明">方法说明</a></li>
<li><a href="#parcelable-与-serializable-对比">Parcelable 与 Serializable 对比</a></li>
<li><a href="#ipc">IPC</a></li>
<li><a href="#ipc方式">IPC方式</a></li>
<li><a href="#binder">Binder</a><ul>
<li><a href="#流程">流程</a></li>
</ul>
</li>
<li><a href="#aidl-通信">AIDL 通信</a></li>
<li><a href="#messenger">Messenger</a></li>
<li><a href="#window--windowmanager">Window / WindowManager</a></li>
<li><a href="#window-概念与分类">Window 概念与分类</a></li>
<li><a href="#window-的内部机制">Window 的内部机制</a></li>
<li><a href="#window-的创建过程">Window 的创建过程</a><ul>
<li><a href="#activity-的-window-创建过程">Activity 的 Window 创建过程</a></li>
<li><a href="#dialog-的-window-创建过程">Dialog 的 Window 创建过程</a></li>
<li><a href="#toast-的-window-创建过程">Toast 的 Window 创建过程</a></li>
</ul>
</li>
<li><a href="#bitmap">Bitmap</a></li>
<li><a href="#配置信息与压缩方式">配置信息与压缩方式</a></li>
<li><a href="#常用操作">常用操作</a><ul>
<li><a href="#裁剪缩放旋转移动">裁剪、缩放、旋转、移动</a></li>
<li><a href="#保存与释放">保存与释放</a></li>
<li><a href="#图片压缩">图片压缩</a></li>
</ul>
</li>
<li><a href="#bitmapfactory">BitmapFactory</a><ul>
<li><a href="#bitmap创建流程">Bitmap创建流程</a></li>
<li><a href="#option类">Option类</a></li>
<li><a href="#基本使用-1">基本使用</a></li>
</ul>
</li>
<li><a href="#内存回收">内存回收</a></li>
<li><a href="#屏幕适配">屏幕适配</a></li>
<li><a href="#单位">单位</a></li>
<li><a href="#头条适配方案">头条适配方案</a></li>
<li><a href="#刘海屏适配">刘海屏适配</a></li>
<li><a href="#context">Context</a></li>
<li><a href="#sharedpreferences">SharedPreferences</a></li>
<li><a href="#获取方式">获取方式</a><ul>
<li><a href="#getpreferences">getPreferences</a></li>
<li><a href="#getdefaultsharedpreferences">getDefaultSharedPreferences</a></li>
<li><a href="#getsharedpreferences">getSharedPreferences</a></li>
</ul>
</li>
<li><a href="#架构">架构</a></li>
<li><a href="#apply--commit">apply / commit</a></li>
<li><a href="#注意">注意</a></li>
<li><a href="#消息机制">消息机制</a></li>
<li><a href="#handler-机制">Handler 机制</a></li>
<li><a href="#工作原理">工作原理</a><ul>
<li><a href="#threadlocal">ThreadLocal</a></li>
<li><a href="#messagequeue">MessageQueue</a></li>
<li><a href="#looper">Looper</a></li>
<li><a href="#handler">Handler</a></li>
</ul>
</li>
<li><a href="#线程异步">线程异步</a></li>
<li><a href="#asynctask">AsyncTask</a><ul>
<li><a href="#基本使用-2">基本使用</a></li>
<li><a href="#工作原理-1">工作原理</a></li>
</ul>
</li>
<li><a href="#handlerthread">HandlerThread</a></li>
<li><a href="#intentservice">IntentService</a></li>
<li><a href="#线程池">线程池</a></li>
<li><a href="#recyclerview-优化">RecyclerView 优化</a></li>
<li><a href="#webview">Webview</a></li>
<li><a href="#基本使用-3">基本使用</a><ul>
<li><a href="#webview-1">WebView</a></li>
<li><a href="#websettings">WebSettings</a></li>
<li><a href="#webviewclient">WebViewClient</a></li>
<li><a href="#webchromeclient">WebChromeClient</a></li>
</ul>
</li>
<li><a href="#webview-加载优化">Webview 加载优化</a></li>
<li><a href="#内存泄漏">内存泄漏</a></li>
</ul>
<h1 id="activity">Activity</h1>
<h2 id="_1">生命周期</h2>
<p><img alt="" src="http://gityuan.com/images/lifecycle/activity.png" /></p>
<ul>
<li>
<p>Activity A 启动另一个Activity B，回调如下:<br />
Activity A 的onPause() → Activity B的onCreate() → onStart() → onResume() → Activity A的onStop()；如果B是透明主题又或则是个DialogActivity，则不会回调A的onStop；</p>
</li>
<li>
<p>使用onSaveInstanceState（）保存简单，轻量级的UI状态</p>
</li>
</ul>
<pre><code class="language-java">lateinit var textView: TextView
var gameState: String? = null

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    gameState = savedInstanceState?.getString(GAME_STATE_KEY)
    setContentView(R.layout.activity_main)
    textView = findViewById(R.id.text_view)
}

override fun onRestoreInstanceState(savedInstanceState: Bundle?) {
    textView.text = savedInstanceState?.getString(TEXT_VIEW_KEY)
}

override fun onSaveInstanceState(outState: Bundle?) {
    outState?.run {
        putString(GAME_STATE_KEY, gameState)
        putString(TEXT_VIEW_KEY, textView.text.toString())
    }
    super.onSaveInstanceState(outState)
}
</code></pre>
<h2 id="_2">启动模式</h2>
<table>
<thead>
<tr>
<th>LaunchMode</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>standard</td>
<td>系统在启动它的任务中创建 activity 的新实例</td>
</tr>
<tr>
<td>singleTop</td>
<td>如果activity的实例已存在于当前任务的顶部，则系统通过调用其onNewIntent()，否则会创建新实例</td>
</tr>
<tr>
<td>singleTask</td>
<td>系统创建新 task 并在 task 的根目录下实例化 activity。但如果 activity 的实例已存在于单独的任务中，则调用其 onNewIntent() 方法，其上面的实例会被移除栈。一次只能存在一个 activity 实例</td>
</tr>
<tr>
<td>singleInstance</td>
<td>相同 singleTask，activity始终是其task的唯一成员; 任何由此开始的activity 都在一个单独的 task 中打开</td>
</tr>
<tr>
<td>&nbsp;</td>
<td></td>
</tr>
<tr>
<td>使用Intent标志</td>
<td>说明</td>
</tr>
<tr>
<td>----------</td>
<td>-----</td>
</tr>
<tr>
<td>FLAG_ACTIVITY_NEW_TASK</td>
<td>同 singleTask</td>
</tr>
<tr>
<td>FLAG_ACTIVITY_SINGLE_TOP</td>
<td>同 singleTop</td>
</tr>
<tr>
<td>FLAG_ACTIVITY_CLEAR_TOP</td>
<td>如果正在启动的 activity 已在当前 task中 运行，则不会启动该activity 的新实例，而是销毁其上的 activity，并调用其 onNewIntent()</td>
</tr>
</tbody>
</table>
<h2 id="_3">启动过程</h2>
<p><img alt="" src="https://img-blog.csdn.net/20180427173504903" /></p>
<p><code>ActivityThread.java</code></p>
<pre><code class="language-java">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    ...
    ActivityInfo aInfo = r.activityInfo;
    if (r.packageInfo == null) {
        //step 1: 创建LoadedApk对象
        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,
                Context.CONTEXT_INCLUDE_CODE);
    }
    ... //component初始化过程

    java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
    //step 2: 创建Activity对象
    Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);
    ...

    //step 3: 创建Application对象
    Application app = r.packageInfo.makeApplication(false, mInstrumentation);

    if (activity != null) {
        //step 4: 创建ContextImpl对象
        Context appContext = createBaseContextForActivity(r, activity);
        CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
        Configuration config = new Configuration(mCompatConfiguration);
        //step5: 将Application/ContextImpl都attach到Activity对象
        activity.attach(appContext, this, getInstrumentation(), r.token,
                r.ident, app, r.intent, r.activityInfo, title, r.parent,
                r.embeddedID, r.lastNonConfigurationInstances, config,
                r.referrer, r.voiceInteractor);

        ...
        int theme = r.activityInfo.getThemeResource();
        if (theme != 0) {
            activity.setTheme(theme);
        }

        activity.mCalled = false;
        if (r.isPersistable()) {
            //step 6: 执行回调onCreate
            mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
        } else {
            mInstrumentation.callActivityOnCreate(activity, r.state);
        }

        r.activity = activity;
        r.stopped = true;
        if (!r.activity.mFinished) {
            activity.performStart(); //执行回调onStart
            r.stopped = false;
        }
        if (!r.activity.mFinished) {
            //执行回调onRestoreInstanceState
            if (r.isPersistable()) {
                if (r.state != null || r.persistentState != null) {
                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,
                            r.persistentState);
                }
            } else if (r.state != null) {
                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
            }
        }
        ...
        r.paused = true;
        mActivities.put(r.token, r);
    }

    return activity;
}

</code></pre>
<h1 id="fragment">Fragment</h1>
<h2 id="_4">特点</h2>
<ul>
<li>Fragment 解决 Activity 间的切换不流畅，轻量切换</li>
<li>可以从 startActivityForResult 中接收到返回结果，但是View不能</li>
<li>只能在 Activity 保存其状态（用户离开 Activity）之前使用 commit() 提交事务。如果您试图在该时间点后提交，则会引发异常。 这是因为如需恢复 Activity，则提交后的状态可能会丢失。 对于丢失提交无关紧要的情况，请使用 commitAllowingStateLoss()。</li>
</ul>
<h2 id="_5">生命周期</h2>
<p><img alt="" src="https://developer.android.google.cn/images/fragment_lifecycle.png" /><img alt="" src="https://developer.android.google.cn/images/activity_fragment_lifecycle.png" />  </p>
<h2 id="activity_1">与Activity通信</h2>
<p>执行此操作的一个好方法是，在片段内定义一个回调接口，并要求宿主 Activity 实现它。</p>
<pre><code class="language-java">public static class FragmentA extends ListFragment {
    ...
    // Container Activity must implement this interface
    public interface OnArticleSelectedListener {
        public void onArticleSelected(Uri articleUri);
    }
    ...
}

public static class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;
    ...
    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mListener = (OnArticleSelectedListener) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException(activity.toString());
        }
    }
    ...
}
</code></pre>
<h1 id="service">Service</h1>
<p>Service 分为两种工作状态，一种是启动状态，主要用于执行后台计算；另一种是绑定状态，主要用于其他组件和 Service 的交互。</p>
<h2 id="_6">启动过程</h2>
<p><img alt="" src="http://gityuan.com/images/android-service/am/Seq_start_service.png" /></p>
<p><code>ActivityThread.java</code></p>
<pre><code class="language-java">@UnsupportedAppUsage
private void handleCreateService(CreateServiceData data) {
    ···
    LoadedApk packageInfo = getPackageInfoNoCheck(
            data.info.applicationInfo, data.compatInfo);
    Service service = null;
    try {
        java.lang.ClassLoader cl = packageInfo.getClassLoader();
        service = packageInfo.getAppFactory()
                .instantiateService(cl, data.info.name, data.intent);
    } 
    ···

    try {
        if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);

        ContextImpl context = ContextImpl.createAppContext(this, packageInfo);
        context.setOuterContext(service);

        Application app = packageInfo.makeApplication(false, mInstrumentation);
        service.attach(context, this, data.info.name, data.token, app,
                ActivityManager.getService());
        service.onCreate();
        mServices.put(data.token, service);
        try {
            ActivityManager.getService().serviceDoneExecuting(
                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } 
    ··· 
}
</code></pre>
<h2 id="_7">绑定过程</h2>
<p><img alt="" src="http://gityuan.com/images/ams/bind_service.jpg" /></p>
<p><code>ActivityThread.java</code></p>
<pre><code class="language-java">private void handleBindService(BindServiceData data) {
    Service s = mServices.get(data.token);
    ···
    if (s != null) {
        try {
            data.intent.setExtrasClassLoader(s.getClassLoader());
            data.intent.prepareToEnterProcess();
            try {
                if (!data.rebind) {
                    IBinder binder = s.onBind(data.intent);
                    ActivityManager.getService().publishService(
                            data.token, data.intent, binder);
                } else {
                    s.onRebind(data.intent);
                    ActivityManager.getService().serviceDoneExecuting(
                            data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
                }
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        } 
        ···
    }
}
</code></pre>
<h2 id="_8">生命周期</h2>
<p><img alt="" src="https://upload-images.jianshu.io/upload_images/944365-cf5c1a9d2dddaaca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/456/format/webp" />
| 值 | 说明 |
|-----|-----|
| START_NOT_STICKY | 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务 |
| START_STICKY | 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务 |
| START_REDELIVER_INTENT | 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务 |</p>
<h2 id="_9">启用前台服务</h2>
<pre><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot;/&gt;
</code></pre>
<pre><code class="language-java">Notification notification = new Notification(icon, text, System.currentTimeMillis());
Intent notificationIntent = new Intent(this, ExampleActivity.class);
PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
notification.setLatestEventInfo(this, title, mmessage, pendingIntent);
startForeground(ONGOING_NOTIFICATION_ID, notification);
</code></pre>
<h1 id="broadcastreceiver">BroadcastReceiver</h1>
<p>target 26 之后，无法在 AndroidManifest 显示声明大部分广播，除了一部分必要的广播，如：
- ACTION_BOOT_COMPLETED
- ACTION_TIME_SET
- ACTION_LOCALE_CHANGED</p>
<pre><code class="language-java">LocalBroadcastManager.getInstance(MainActivity.this).registerReceiver(receiver, filter);
</code></pre>
<h2 id="_10">注册过程</h2>
<p><img alt="" src="http://gityuan.com/images/ams/send_broadcast.jpg" /></p>
<h1 id="contentprovider">ContentProvider</h1>
<p>ContentProvider 管理对结构化数据集的访问。它们封装数据，并提供用于定义数据安全性的机制。 内容提供程序是连接一个进程中的数据与另一个进程中运行的代码的标准界面。</p>
<p>ContentProvider 无法被用户感知，对于一个 ContentProvider 组件来说，它的内部需要实现增删该查这四种操作，它的内部维持着一份数据集合，这个数据集合既可以是数据库实现，也可以是其他任何类型，如 List 和 Map，内部的 insert、delete、update、query 方法需要处理好线程同步，因为这几个方法是在 Binder 线程池中被调用的。</p>
<p>ContentProvider 通过 Binder 向其他组件乃至其他应用提供数据。当 ContentProvider 所在的进程启动时，ContentProvider 会同时启动并发布到 AMS 中，需要注意的是，这个时候 ContentProvider 的 onCreate 要先于 Application 的 onCreate 而执行。</p>
<h2 id="_11">基本使用</h2>
<pre><code class="language-java">// Queries the user dictionary and returns results
mCursor = getContentResolver().query(
    UserDictionary.Words.CONTENT_URI,   // The content URI of the words table
    mProjection,                        // The columns to return for each row
    mSelectionClause                    // Selection criteria
    mSelectionArgs,                     // Selection criteria
    mSortOrder);                        // The sort order for the returned rows
</code></pre>
<pre><code class="language-java">public class Installer extends ContentProvider {

    @Override
    public boolean onCreate() {
        return true;
    }

    @Nullable
    @Override
    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {
        return null;
    }

    @Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        return null;
    }

    @Nullable
    @Override
    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
        return null;
    }

    @Override
    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {
        return 0;
    }

    @Override
    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {
        return 0;
    }
}
</code></pre>
<blockquote>
<p>ContentProvider 和 sql 在实现上有什么区别?
- ContentProvider 屏蔽了数据存储的细节，内部实现透明化，用户只需关心 uri 即可(是否匹配)
- ContentProvider 能实现不同 app 的数据共享，sql 只能是自己程序才能访问
- Contentprovider 还能增删本地的文件,xml等信息</p>
</blockquote>
<h1 id="_12">数据存储</h1>
<table>
<thead>
<tr>
<th>存储方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SharedPreferences</td>
<td>在键值对中存储私有原始数据</td>
</tr>
<tr>
<td>内部存储</td>
<td>在设备内存中存储私有数据</td>
</tr>
<tr>
<td>外部存储</td>
<td>在共享的外部存储中存储公共数据</td>
</tr>
<tr>
<td>SQLite 数据库</td>
<td>在私有数据库中存储结构化数据</td>
</tr>
</tbody>
</table>
<h1 id="view">View</h1>
<p><img alt="" src="https://user-gold-cdn.xitu.io/2019/6/12/16b4a8a388f3a91a?imageslim" />
ViewRoot 对应于 ViewRootImpl 类，它是连接 WindowManager 和 DecorView 的纽带，View 的三大流程均是通过 ViewRoot 来完成的。在 ActivityThread 中，当 Activity 对象被创建完毕后，会将 DecorView 添加到 Window 中，同时会创建 ViewRootImpl 对象，并将 ViewRootImpl 对象和 DecorView 建立关联</p>
<p>View 的整个绘制流程可以分为以下三个阶段：
- measure: 判断是否需要重新计算 View 的大小，需要的话则计算
- layout: 判断是否需要重新计算 View 的位置，需要的话则计算
- draw: 判断是否需要重新绘制 View，需要的话则重绘制</p>
<p><img alt="" src="https://img-blog.csdn.net/20180510164327114" /></p>
<h2 id="measurespec">MeasureSpec</h2>
<p>MeasureSpec表示的是一个32位的整形值，它的高2位表示测量模式SpecMode，低30位表示某种测量模式下的规格大小SpecSize。MeasureSpec 是 View 类的一个静态内部类，用来说明应该如何测量这个 View</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNSPECIFIED</td>
<td>不指定测量模式, 父视图没有限制子视图的大小，子视图可以是想要的任何尺寸，通常用于系统内部，应用开发中很少用到。</td>
</tr>
<tr>
<td>EXACTLY</td>
<td>精确测量模式，视图宽高指定为 match_parent 或具体数值时生效，表示父视图已经决定了子视图的精确大小，这种模式下 View 的测量值就是 SpecSize 的值</td>
</tr>
<tr>
<td>AT_MOST</td>
<td>最大值测量模式，当视图的宽高指定为 wrap_content 时生效，此时子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸</td>
</tr>
</tbody>
</table>
<p>对于 DecorView 而言，它的MeasureSpec 由窗口尺寸和其自身的 LayoutParams 共同决定；对于普通的 View，它的 MeasureSpec 由父视图的 MeasureSpec 和其自身的 LayoutParams 共同决定</p>
<table>
<thead>
<tr>
<th>childLayoutParams/parentSpecMode</th>
<th>EXACTLY</th>
<th>AT_MOST</th>
</tr>
</thead>
<tbody>
<tr>
<td>dp/px</td>
<td>EXACTLY(childSize)</td>
<td>EXACTLY(childSize)</td>
</tr>
<tr>
<td>match_parent</td>
<td>EXACTLY(childSize)</td>
<td>AT_MOST(parentSize)</td>
</tr>
<tr>
<td>wrap_content</td>
<td>AT_MOST(parentSize)</td>
<td>AT_MOST(parentSize)</td>
</tr>
</tbody>
</table>
<p>直接继承 View 的控件需要重写 onMeasure 方法并设置 wrap_content 时的自身大小，因为 View 在布局中使用 wrap_content，那么它的 specMode 是 AT_MOST 模式，在这种模式下，它的宽/高等于父容器当前剩余的空间大小，就相当于使用 match_parent。这解决方式如下：</p>
<pre><code class="language-java">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
    int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
    int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
    int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);
    // 在 wrap_content 的情况下指定内部宽/高(mWidth 和 mHeight`)
    if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) {
        setMeasuredDimension(mWidth, mHeight);
    } else if (widthSpecMode == MeasureSpec.AT_MOST) {
        setMeasureDimension(mWidth, heightSpecSize);
    } else if (heightSpecMode == MeasureSpec.AT_MOST) {
        setMeasureDimension(widthSpecSize, mHeight);
    }
}
</code></pre>
<h2 id="motionevent">MotionEvent</h2>
<table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACTION_DOWN</td>
<td>手指刚接触到屏幕</td>
</tr>
<tr>
<td>ACTION_MOVE</td>
<td>手指在屏幕上移动</td>
</tr>
<tr>
<td>ACTION_UP</td>
<td>手机从屏幕上松开的一瞬间</td>
</tr>
<tr>
<td>ACTION_CANCEL</td>
<td>触摸事件取消</td>
</tr>
</tbody>
</table>
<p>点击屏幕后松开，事件序列为 DOWN -&gt; UP，点击屏幕滑动松开，事件序列为 DOWN -&gt; MOVE -&gt; ...&gt; MOVE -&gt; UP。</p>
<p><code>getX/getY</code> 返回相对于当前View左上角的坐标，<code>getRawX/getRawY</code> 返回相对于屏幕左上角的坐标</p>
<p>TouchSlop是系统所能识别出的被认为滑动的最小距离，不同设备值可能不相同，可通过 <code>ViewConfiguration.get(getContext()).getScaledTouchSlop()</code> 获取。</p>
<h2 id="velocitytracker">VelocityTracker</h2>
<p><strong>VelocityTracker</strong> 可用于追踪手指在滑动中的速度：</p>
<pre><code class="language-java">view.setOnTouchListener(new View.OnTouchListener() {
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        VelocityTracker velocityTracker = VelocityTracker.obtain();
        velocityTracker.addMovement(event);
        velocityTracker.computeCurrentVelocity(1000);
        int xVelocity = (int) velocityTracker.getXVelocity();
        int yVelocity = (int) velocityTracker.getYVelocity();
        velocityTracker.clear();
        velocityTracker.recycle();
        return false;
    }
});
</code></pre>
<h2 id="gesturedetector">GestureDetector</h2>
<p><strong>GestureDetector</strong> 辅助检测用户的单击、滑动、长按、双击等行为：</p>
<pre><code class="language-java">final GestureDetector mGestureDetector = new GestureDetector(this, new GestureDetector.OnGestureListener() {
    @Override
    public boolean onDown(MotionEvent e) { return false; }

    @Override
    public void onShowPress(MotionEvent e) { }

    @Override
    public boolean onSingleTapUp(MotionEvent e) { return false; }

    @Override
    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) { return false; }

    @Override
    public void onLongPress(MotionEvent e) { }

    @Override
    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { return false; }
});
mGestureDetector.setOnDoubleTapListener(new OnDoubleTapListener() {
    @Override
    public boolean onSingleTapConfirmed(MotionEvent e) { return false; }

    @Override
    public boolean onDoubleTap(MotionEvent e) { return false; }

    @Override
    public boolean onDoubleTapEvent(MotionEvent e) { return false; }
});
// 解决长按屏幕后无法拖动的问题
mGestureDetector.setIsLongpressEnabled(false);
imageView.setOnTouchListener(new View.OnTouchListener() {
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        return mGestureDetector.onTouchEvent(event);
    }
});
</code></pre>
<p>如果是监听滑动相关，建议在 <code>onTouchEvent</code> 中实现，如果要监听双击，那么就使用 <code>GestureDectector</code>。</p>
<h2 id="scroller">Scroller</h2>
<p>弹性滑动对象，用于实现 View 的弹性滑动，<strong>Scroller</strong> 本身无法让 View 弹性滑动，需要和 View 的 <code>computeScroll</code> 方法配合使用。<code>startScroll</code> 方法是无法让 View 滑动的，<code>invalidate</code> 会导致 View 重绘，重绘后会在 <code>draw</code> 方法中又会去调用 <code>computeScroll</code> 方法，<code>computeScroll</code> 方法又会去向 Scroller 获取当前的 scrollX 和 scrollY，然后通过 <code>scrollTo</code> 方法实现滑动，接着又调用 <code>postInvalidate</code> 方法如此反复。</p>
<pre><code class="language-java">Scroller mScroller = new Scroller(mContext);

private void smoothScrollTo(int destX) {
    int scrollX = getScrollX();
    int delta = destX - scrollX;
    // 1000ms 内滑向 destX，效果就是慢慢滑动
    mScroller.startScroll(scrollX, 0 , delta, 0, 1000);
    invalidate();
}

@Override
public void computeScroll() {
    if (mScroller.computeScrollOffset()) {
        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
        postInvalidate();
    }
}
</code></pre>
<h2 id="view_1">View 的滑动</h2>
<ul>
<li><code>scrollTo/scrollBy</code><br />
适合对 View 内容的滑动。<code>scrollBy</code> 实际上也是调用了 <code>scrollTo</code> 方法：</li>
</ul>
<pre><code class="language-java">public void scrollTo(int x, int y) {
    if (mScrollX != x || mScrollY != y) {
        int oldX = mScrollX;
        int oldY = mScrollY;
        mScrollX = x;
        mScrollY = y;
        invalidateParentCaches();
        onScrollChanged(mScrollX, mScrollY, oldX, oldY);
        if (!awakenScrollBars()) {
            postInvalidateOnAnimation();
        }
    }
}

public void scrollBy(int x, int y) {
    scrollTo(mScrollX + x, mScrollY + y);
}
</code></pre>
<p>mScrollX的值等于 View 的左边缘和 View 内容左边缘在水平方向的距离，mScrollY的值等于 View 上边缘和 View 内容上边缘在竖直方向的距离。<code>scrollTo</code> 和 <code>scrollBy</code> 只能改变 View 内容的位置而不能改变 View 在布局中的位置。</p>
<ul>
<li>使用动画<br />
操作简单，主要适用于没有交互的 View 和实现复杂的动画效果。</li>
<li>改变布局参数
操作稍微复杂，适用于有交互的 View.</li>
</ul>
<pre><code class="language-java">ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) view.getLayoutParams();
params.width += 100;
params.leftMargin += 100;
view.requestLayout();
//或者 view.setLayoutParams(params);
</code></pre>
<h2 id="view_2">View 的事件分发</h2>
<p>点击事件达到顶级 View(一般是一个 ViewGroup)，会调用 ViewGroup 的 dispatchTouchEvent 方法，如果顶级 ViewGroup 拦截事件即 onInterceptTouchEvent 返回 true，则事件由 ViewGroup 处理，这时如果 ViewGroup 的 mOnTouchListener 被设置，则 onTouch 会被调用，否则 onTouchEvent 会被调用。也就是说如果都提供的话，onTouch 会屏蔽掉 onTouchEvent。在 onTouchEvent 中，如果设置了 mOnClickListenser，则 onClick 会被调用。如果顶级 ViewGroup 不拦截事件，则事件会传递给它所在的点击事件链上的子 View，这时子 View 的 dispatchTouchEvent 会被调用。如此循环。</p>
<p><img alt="" src="https://user-gold-cdn.xitu.io/2019/7/19/16c08654e36be140?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" /></p>
<p><img alt="" src="https://user-gold-cdn.xitu.io/2019/7/19/16c086493dc70018?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" /></p>
<ul>
<li>
<p>ViewGroup 默认不拦截任何事件。ViewGroup 的 onInterceptTouchEvent 方法默认返回 false。</p>
</li>
<li>
<p>View 没有 onInterceptTouchEvent 方法，一旦有点击事件传递给它，onTouchEvent 方法就会被调用。</p>
</li>
<li>
<p>View 在可点击状态下，onTouchEvent 默认会消耗事件。</p>
</li>
<li>
<p>ACTION_DOWN 被拦截了，onInterceptTouchEvent 方法执行一次后，就会留下记号（mFirstTouchTarget == null）那么往后的 ACTION_MOVE 和 ACTION_UP 都会拦截。`</p>
</li>
</ul>
<h2 id="activity-view">在 Activity 中获取某个 View 的宽高</h2>
<ul>
<li>Activity/View#onWindowFocusChanged</li>
</ul>
<pre><code>// 此时View已经初始化完毕
// 当Activity的窗口得到焦点和失去焦点时均会被调用一次
// 如果频繁地进行onResume和onPause，那么onWindowFocusChanged也会被频繁地调用
public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    if (hasFocus) {
        int width = view.getMeasureWidth();
        int height = view.getMeasuredHeight();
    }
}
</code></pre>
<ul>
<li>view.post(runnable)</li>
</ul>
<pre><code>// 通过post可以将一个runnable投递到消息队列的尾部，// 然后等待Looper调用次runnable的时候，View也已经初
// 始化好了
protected void onStart() {
    super.onStart();
    view.post(new Runnable() {

        @Override
        public void run() {
            int width = view.getMeasuredWidth();
            int height = view.getMeasuredHeight();
        }
    });
}
</code></pre>
<ul>
<li>ViewTreeObserver</li>
</ul>
<pre><code class="language-java">// 当View树的状态发生改变或者View树内部的View的可见// 性发生改变时，onGlobalLayout方法将被回调
protected void onStart() {
    super.onStart();

    ViewTreeObserver observer = view.getViewTreeObserver();
    observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {

        @SuppressWarnings(&quot;deprecation&quot;)
        @Override
        public void onGlobalLayout() {
            view.getViewTreeObserver().removeGlobalOnLayoutListener(this);
            int width = view.getMeasuredWidth();
            int height = view.getMeasuredHeight();
        }
    });
}
</code></pre>
<h2 id="draw">Draw 的基本流程</h2>
<pre><code class="language-java">// 绘制基本上可以分为六个步骤
public void draw(Canvas canvas) {
    ...
    // 步骤一：绘制View的背景
    drawBackground(canvas);
    ...
    // 步骤二：如果需要的话，保持canvas的图层，为fading做准备
    saveCount = canvas.getSaveCount();
    ...
    canvas.saveLayer(left, top, right, top + length, null, flags);
    ...
    // 步骤三：绘制View的内容
    onDraw(canvas);
    ...
    // 步骤四：绘制View的子View
    dispatchDraw(canvas);
    ...
    // 步骤五：如果需要的话，绘制View的fading边缘并恢复图层
    canvas.drawRect(left, top, right, top + length, p);
    ...
    canvas.restoreToCount(saveCount);
    ...
    // 步骤六：绘制View的装饰(例如滚动条等等)
    onDrawForeground(canvas)
}
</code></pre>
<h2 id="view_3">自定义 View</h2>
<ul>
<li>继承 View 重写 <code>onDraw</code> 方法</li>
</ul>
<p>主要用于实现一些不规则的效果，静态或者动态地显示一些不规则的图形，即重写 <code>onDraw</code> 方法。采用这种方式需要自己支持 wrap_content，并且 padding 也需要自己处理。</p>
<ul>
<li>继承 ViewGroup 派生特殊的 Layout</li>
</ul>
<p>主要用于实现自定义布局，采用这种方式需要合适地处理 ViewGroup 的测量、布局两个过程，并同时处理子元素的测量和布局过程。</p>
<ul>
<li>继承特定的 View</li>
</ul>
<p>用于扩张某种已有的View的功能</p>
<ul>
<li>继承特定的 ViewGroup</li>
</ul>
<p>用于扩张某种已有的ViewGroup的功能</p>
<h1 id="_13">进程</h1>
<p>进程（Process） 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p>
<p>当某个应用组件启动且该应用没有运行其他任何组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。</p>
<p>各类组件元素的清单文件条目<code>&lt;activity&gt;</code>、<code>&lt;service&gt;</code>、<code>&lt;receiver&gt;</code> 和 <code>&lt;provider&gt;</code>—均支持 android:process 属性，此属性可以指定该组件应在哪个进程运行。</p>
<h2 id="_14">进程生命周期</h2>
<p><strong>1、前台进程</strong>
- 托管用户正在交互的 Activity（已调用 Activity 的 <code>onResume()</code> 方法）
- 托管某个 Service，后者绑定到用户正在交互的 Activity
- 托管正在“前台”运行的 Service（服务已调用 <code>startForeground()</code>）
- 托管正执行一个生命周期回调的 Service（<code>onCreate()</code>、<code>onStart()</code> 或 <code>onDestroy()</code>）
- 托管正执行其 <code>onReceive()</code> 方法的 BroadcastReceiver</p>
<p><strong>2、可见进程</strong><br />
- 托管不在前台、但仍对用户可见的 Activity（已调用其 <code>onPause()</code> 方法）。例如，如果 re前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。
- 托管绑定到可见（或前台）Activity 的 Service</p>
<p><strong>3、服务进程</strong><br />
- 正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。</p>
<p><strong>4、后台进程</strong>
- 包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 <code>onStop()</code> 方法）。通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。</p>
<p><strong>5、空进程</strong>
- 不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。\</p>
<h2 id="_15">多进程</h2>
<p>如果注册的四大组件中的任意一个组件时用到了多进程，运行该组件时，都会创建一个新的 Application 对象。对于多进程重复创建 Application 这种情况，只需要在该类中对当前进程加以判断即可。</p>
<pre><code class="language-java">public class MyApplication extends Application {

    @Override
    public void onCreate() {
        Log.d(&quot;MyApplication&quot;, getProcessName(android.os.Process.myPid()));
        super.onCreate();
    }

    /**
     * 根据进程 ID 获取进程名
     * @param pid 进程id
     * @return 进程名
     */
    public  String getProcessName(int pid){
        ActivityManager am = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);
        List&lt;ActivityManager.RunningAppProcessInfo&gt; processInfoList = am.getRunningAppProcesses();
        if (processInfoList == null) {
            return null;
        }
        for (ActivityManager.RunningAppProcessInfo processInfo : processInfoList) {
            if (processInfo.pid == pid) {
                return processInfo.processName;
            }
        }
        return null;
    }
}
</code></pre>
<blockquote>
<p>一般来说，使用多进程会造成以下几个方面的问题：
- 静态成员和单例模式完全失效
- 线程同步机制完全失效
- SharedPreferences 的可靠性下降
- Application 会多次创建</p>
</blockquote>
<h2 id="_16">进程存活</h2>
<h3 id="oom_adj">OOM_ADJ</h3>
<table>
<thead>
<tr>
<th>ADJ级别</th>
<th>取值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNKNOWN_ADJ</td>
<td>16</td>
<td>一般指将要会缓存进程，无法获取确定值</td>
</tr>
<tr>
<td>CACHED_APP_MAX_ADJ</td>
<td>15</td>
<td>不可见进程的adj最大值</td>
</tr>
<tr>
<td>CACHED_APP_MIN_ADJ</td>
<td>9</td>
<td>不可见进程的adj最小值</td>
</tr>
<tr>
<td>SERVICE_B_AD</td>
<td>8</td>
<td>B List 中的 Service（较老的、使用可能性更小）</td>
</tr>
<tr>
<td>PREVIOUS_APP_ADJ</td>
<td>7</td>
<td>上一个App的进程(往往通过按返回键)</td>
</tr>
<tr>
<td>HOME_APP_ADJ</td>
<td>6</td>
<td>Home进程</td>
</tr>
<tr>
<td>SERVICE_ADJ</td>
<td>5</td>
<td>服务进程(Service process)</td>
</tr>
<tr>
<td>HEAVY_WEIGHT_APP_ADJ</td>
<td>4</td>
<td>后台的重量级进程，system/rootdir/init.rc 文件中设置</td>
</tr>
<tr>
<td>BACKUP_APP_ADJ</td>
<td>3</td>
<td>备份进程</td>
</tr>
<tr>
<td>PERCEPTIBLE_APP_ADJ</td>
<td>2</td>
<td>可感知进程，比如后台音乐播放</td>
</tr>
<tr>
<td>VISIBLE_APP_ADJ</td>
<td>1</td>
<td>可见进程(Visible process)</td>
</tr>
<tr>
<td>FOREGROUND_APP_ADJ</td>
<td>0</td>
<td>前台进程（Foreground process)</td>
</tr>
<tr>
<td>PERSISTENT_SERVICE_ADJ</td>
<td>-11</td>
<td>关联着系统或persistent进程</td>
</tr>
<tr>
<td>PERSISTENT_PROC_ADJ</td>
<td>-12</td>
<td>系统 persistent 进程，比如telephony</td>
</tr>
<tr>
<td>SYSTEM_ADJ</td>
<td>-16</td>
<td>系统进程</td>
</tr>
<tr>
<td>NATIVE_ADJ</td>
<td>-17</td>
<td>native进程（不被系统管理）</td>
</tr>
</tbody>
</table>
<h3 id="_17">进程被杀情况</h3>
<p><img alt="" src="https://pic3.zhimg.com/80/18b6bfb1bf54433619a7122c3a8e606e_hd.png" /></p>
<h3 id="_18">进程保活方案</h3>
<ul>
<li>开启一个像素的 Activity</li>
<li>使用前台服务</li>
<li>多进程相互唤醒</li>
<li>JobSheduler 唤醒</li>
<li>粘性服务 &amp; 与系统服务捆绑</li>
</ul>
<h1 id="parcelable">Parcelable 接口</h1>
<p>只要实现了 Parcelable 接口，一个类的对象就可以实现序列化并可以通过 Intent 和 Binder 传递。</p>
<h2 id="_19">使用示例</h2>
<pre><code class="language-java">import android.os.Parcel;
import android.os.Parcelable;

public class User implements Parcelable {

    private int userId;

    protected User(Parcel in) {
        userId = in.readInt();
    }

    public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() {
        @Override
        public User createFromParcel(Parcel in) {
            return new User(in);
        }

        @Override
        public User[] newArray(int size) {
            return new User[size];
        }
    };

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(userId);
    }

    public int getUserId() {
        return userId;
    }
}
</code></pre>
<h2 id="_20">方法说明</h2>
<p>Parcel 内部包装了可序列化的数据，可以在 Binder 中自由传输。序列化功能由 <code>writeToParcel</code> 方法完成，最终是通过 Parcel 中的一系列 write 方法完成。反序列化功能由 CREATOR 来完成，通过 Parcel 的一系列 read 方法来完成反序列化过程。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>createFromParcel(Parcel in)</td>
<td>从序列化后的对象中创建原始对象</td>
</tr>
<tr>
<td>newArray(int size)</td>
<td>创建指定长度的原始对象数组</td>
</tr>
<tr>
<td>User(Parcel in)</td>
<td>从序列化后的对象中创建原始对象</td>
</tr>
<tr>
<td>writeToParcel(Parcel dest, int flags)</td>
<td>将当前对象写入序列化结构中，其中 flags 标识有两种值：0 或者 1。为 1 时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为 0</td>
</tr>
<tr>
<td>describeContents</td>
<td>返回当前对象的内容描述。如果含有文件描述符，返回 1，否则返回 0，几乎所有情况都返回 0</td>
</tr>
</tbody>
</table>
<h2 id="parcelable-serializable">Parcelable 与 Serializable 对比</h2>
<ul>
<li>Serializable 使用 I/O 读写存储在硬盘上，而 Parcelable 是直接在内存中读写</li>
<li>Serializable 会使用反射，序列化和反序列化过程需要大量 I/O 操作， Parcelable 自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多</li>
</ul>
<h1 id="ipc">IPC</h1>
<p>IPC 即 Inter-Process Communication (进程间通信)。Android 基于 Linux，而 Linux 出于安全考虑，不同进程间不能之间操作对方的数据，这叫做“进程隔离”。</p>
<blockquote>
<p>在 Linux 系统中，虚拟内存机制为每个进程分配了线性连续的内存空间，操作系统将这种虚拟内存空间映射到物理内存空间，每个进程有自己的虚拟内存空间，进而不能操作其他进程的内存空间，只有操作系统才有权限操作物理内存空间。 进程隔离保证了每个进程的内存安全。</p>
</blockquote>
<h2 id="ipc_1">IPC方式</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bundle</td>
<td>简单易用</td>
<td>只能传输 Bundle 支持的数据类型</td>
<td>四大组件间的进程间通信</td>
</tr>
<tr>
<td>文件共享</td>
<td>简单易用</td>
<td>不适合高并发场景，并且无法做到进程间即时通信</td>
<td>无并发访问情形，交换简单的数据实时性不高的场景</td>
</tr>
<tr>
<td>AIDL</td>
<td>功能强大，支持一对多并发通信，支持实时通信</td>
<td>使用稍复杂，需要处理好线程同步</td>
<td>一对多通信且有 RPC 需求</td>
</tr>
<tr>
<td>Messenger</td>
<td>功能一般，支持一对多串行通信，支持实时通信</td>
<td>不能很处理高并发清醒，不支持 RPC，数据通过 Message 进行传输，因此只能传输 Bundle 支持的数据类型</td>
<td>低并发的一对多即时通信，无RPC需求，或者无需返回结果的RPC需求</td>
</tr>
<tr>
<td>ContentProvider</td>
<td>在数据源访问方面功能强大，支持一对多并发数据共享，可通过 Call 方法扩展其他操作</td>
<td>可以理解为受约束的 AIDL，主要提供数据源的 CRUD 操作</td>
<td>一对多的进程间数据共享</td>
</tr>
<tr>
<td>Socket</td>
<td>可以通过网络传输字节流，支持一对多并发实时通信</td>
<td>实现细节稍微有点烦琐，不支持直接的RPC</td>
<td>网络数据交换</td>
</tr>
</tbody>
</table>
<h2 id="binder">Binder</h2>
<p>Binder 是 Android 中的一个类，实现了 IBinder 接口。从 IPC 角度来说，Binder 是 Android 中的一种扩进程通信方方式。从 Android 应用层来说，Binder 是客户端和服务器端进行通信的媒介，当 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象。</p>
<p>Binder 相较于传统 IPC 来说更适合于Android系统，具体原因的包括如下三点：
- Binder 本身是 C/S 架构的，这一点更符合 Android 系统的架构
- 性能上更有优势：管道，消息队列，Socket 的通讯都需要两次数据拷贝，而 Binder 只需要一次。要知道，对于系统底层的 IPC 形式，少一次数据拷贝，对整体性能的影响是非常之大的
- 安全性更好：传统 IPC 形式，无法得到对方的身份标识（UID/GID)，而在使用 Binder IPC 时，这些身份标示是跟随调用过程而自动传递的。Server 端很容易就可以知道 Client 端的身份，非常便于做安全检查</p>
<p>示例：</p>
<ul>
<li><strong>新建AIDL接口文件</strong></li>
</ul>
<p><code>RemoteService.aidl</code></p>
<pre><code class="language-java">package com.example.mystudyapplication3;

interface IRemoteService {

    int getUserId();

}
</code></pre>
<p>系统会自动生成 <code>IRemoteService.java</code>:</p>
<pre><code class="language-java">/*
 * This file is auto-generated.  DO NOT MODIFY.
 */
package com.example.mystudyapplication3;
// Declare any non-default types here with import statements
//import com.example.mystudyapplication3.IUserBean;

public interface IRemoteService extends android.os.IInterface {
    /**
     * Local-side IPC implementation stub class.
     */
    public static abstract class Stub extends android.os.Binder implements com.example.mystudyapplication3.IRemoteService {
        private static final java.lang.String DESCRIPTOR = &quot;com.example.mystudyapplication3.IRemoteService&quot;;

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }

        /**
         * Cast an IBinder object into an com.example.mystudyapplication3.IRemoteService interface,
         * generating a proxy if needed.
         */
        public static com.example.mystudyapplication3.IRemoteService asInterface(android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) &amp;&amp; (iin instanceof com.example.mystudyapplication3.IRemoteService))) {
                return ((com.example.mystudyapplication3.IRemoteService) iin);
            }
            return new com.example.mystudyapplication3.IRemoteService.Stub.Proxy(obj);
        }

        @Override
        public android.os.IBinder asBinder() {
            return this;
        }

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
            java.lang.String descriptor = DESCRIPTOR;
            switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(descriptor);
                    return true;
                }
                case TRANSACTION_getUserId: {
                    data.enforceInterface(descriptor);
                    int _result = this.getUserId();
                    reply.writeNoException();
                    reply.writeInt(_result);
                    return true;
                }
                default: {
                    return super.onTransact(code, data, reply, flags);
                }
            }
        }

        private static class Proxy implements com.example.mystudyapplication3.IRemoteService {
            private android.os.IBinder mRemote;

            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }

            @Override
            public android.os.IBinder asBinder() {
                return mRemote;
            }

            public java.lang.String getInterfaceDescriptor() {
                return DESCRIPTOR;
            }

            @Override
            public int getUserId() throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                int _result;
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    mRemote.transact(Stub.TRANSACTION_getUserId, _data, _reply, 0);
                    _reply.readException();
                    _result = _reply.readInt();
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
                return _result;
            }
        }

        static final int TRANSACTION_getUserId = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
    }

    public int getUserId() throws android.os.RemoteException;
}
</code></pre>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>DESCRIPTOR</td>
<td>Binder 的唯一标识，一般用当前的 Binder 的类名表示</td>
</tr>
<tr>
<td>asInterface(IBinder obj)</td>
<td>将服务端的 Binder 对象成客户端所需的 AIDL 接口类型对象，这种转换过程是区分进程的，如果位于同一进程，返回的就是 Stub 对象本身，否则返回的是系统封装后的 Stub.proxy 对象。</td>
</tr>
<tr>
<td>asBinder</td>
<td>用于返回当前 Binder 对象</td>
</tr>
<tr>
<td>onTransact</td>
<td>运行在服务端中的 Binder 线程池中，远程请求会通过系统底层封装后交由此方法来处理</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>定向 tag</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>数据只能由客户端流向服务端，服务端将会收到客户端对象的完整数据，客户端对象不会因为服务端对传参的修改而发生变动。</td>
</tr>
<tr>
<td>out</td>
<td>数据只能由服务端流向客户端，服务端将会收到客户端对象，该对象不为空，但是它里面的字段为空，但是在服务端对该对象作任何修改之后客户端的传参对象都会同步改动。</td>
</tr>
<tr>
<td>inout</td>
<td>服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。</td>
</tr>
</tbody>
</table>
<h3 id="_21">流程</h3>
<p><img alt="" src="http://gityuan.com/images/binder/binder_start_service/binder_ipc_arch.jpg" /></p>
<h2 id="aidl">AIDL 通信</h2>
<p>Android Interface Definition Language</p>
<p>使用示例：
- <strong>新建AIDL接口文件</strong></p>
<pre><code class="language-java">// RemoteService.aidl
package com.example.mystudyapplication3;

interface IRemoteService {

    int getUserId();

}
</code></pre>
<ul>
<li><strong>创建远程服务</strong></li>
</ul>
<pre><code class="language-java">public class RemoteService extends Service {

    private int mId = -1;

    private Binder binder = new IRemoteService.Stub() {

        @Override
        public int getUserId() throws RemoteException {
            return mId;
        }
    };

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        mId = 1256;
        return binder;
    }
}
</code></pre>
<ul>
<li><strong>声明远程服务</strong></li>
</ul>
<pre><code class="language-java">&lt;service
    android:name=&quot;.RemoteService&quot;
    android:process=&quot;:aidl&quot; /&gt;
</code></pre>
<ul>
<li><strong>绑定远程服务</strong></li>
</ul>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity {

    public static final String TAG = &quot;wzq&quot;;

    IRemoteService iRemoteService;
    private ServiceConnection mConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            iRemoteService = IRemoteService.Stub.asInterface(service);
            try {
                Log.d(TAG, String.valueOf(iRemoteService.getUserId()));
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            iRemoteService = null;
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        bindService(new Intent(MainActivity.this, RemoteService.class), mConnection, Context.BIND_AUTO_CREATE);
    }
}
</code></pre>
<h2 id="messenger">Messenger</h2>
<p>Messenger可以在不同进程中传递 Message 对象，在Message中放入我们需要传递的数据，就可以轻松地实现数据的进程间传递了。Messenger 是一种轻量级的 IPC 方案，底层实现是 AIDL。</p>
<h1 id="window-windowmanager">Window / WindowManager</h1>
<h2 id="window">Window 概念与分类</h2>
<p>Window 是一个抽象类，它的具体实现是 PhoneWindow。WindowManager 是外界访问 Window 的入口，Window 的具体实现位于 WindowManagerService 中，WindowManager 和 WindowManagerService 的交互是一个 IPC 过程。Android 中所有的视图都是通过 Window 来呈现，因此 Window 实际是 View 的直接管理者。</p>
<table>
<thead>
<tr>
<th>Window 类型</th>
<th>说明</th>
<th>层级</th>
</tr>
</thead>
<tbody>
<tr>
<td>Application Window</td>
<td>对应着一个 Activity</td>
<td>1~99</td>
</tr>
<tr>
<td>Sub Window</td>
<td>不能单独存在，只能附属在父 Window 中，如 Dialog 等</td>
<td>1000~1999</td>
</tr>
<tr>
<td>System Window</td>
<td>需要权限声明，如 Toast 和 系统状态栏等</td>
<td>2000~2999</td>
</tr>
</tbody>
</table>
<h2 id="window_1">Window 的内部机制</h2>
<p>Window 是一个抽象的概念，每一个 Window 对应着一个 View 和一个 ViewRootImpl。Window 实际是不存在的，它是以 View 的形式存在。对 Window 的访问必须通过 WindowManager，WindowManager 的实现类是 WindowManagerImpl：</p>
<p><code>WindowManagerImpl.java</code></p>
<pre><code class="language-java">@Override
public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
    applyDefaultToken(params);
    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
}

@Override
public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
    applyDefaultToken(params);
    mGlobal.updateViewLayout(view, params);
}

@Override
public void removeView(View view) {
    mGlobal.removeView(view, false);
}
</code></pre>
<p>WindowManagerImpl 没有直接实现 Window 的三大操作，而是全部交给 WindowManagerGlobal 处理，WindowManagerGlobal 以工厂的形式向外提供自己的实例：</p>
<p><code>WindowManagerGlobal.java</code></p>
<pre><code class="language-java">// 添加
public void addView(View view, ViewGroup.LayoutParams params,
        Display display, Window parentWindow) {
    ···
    // 子 Window 的话需要调整一些布局参数
    final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;
    if (parentWindow != null) {
        parentWindow.adjustLayoutParamsForSubWindow(wparams);
    } else {
        ···
    }
    ViewRootImpl root;
    View panelParentView = null;
    synchronized (mLock) {
        // 新建一个 ViewRootImpl，并通过其 setView 来更新界面完成 Window 的添加过程
        ···
        root = new ViewRootImpl(view.getContext(), display);
        view.setLayoutParams(wparams);
        mViews.add(view);
        mRoots.add(root);
        mParams.add(wparams);
        // do this last because it fires off messages to start doing things
        try {
            root.setView(view, wparams, panelParentView);
        } catch (RuntimeException e) {
            // BadTokenException or InvalidDisplayException, clean up.
            if (index &gt;= 0) {
                removeViewLocked(index, true);
            }
            throw e;
        }
    }
}

// 删除
@UnsupportedAppUsage
public void removeView(View view, boolean immediate) {
    ···
    synchronized (mLock) {
        int index = findViewLocked(view, true);
        View curView = mRoots.get(index).getView();
        removeViewLocked(index, immediate);
        ···
    }
}

private void removeViewLocked(int index, boolean immediate) {
    ViewRootImpl root = mRoots.get(index);
    View view = root.getView();
    if (view != null) {
        InputMethodManager imm = InputMethodManager.getInstance();
        if (imm != null) {
            imm.windowDismissed(mViews.get(index).getWindowToken());
        }
    }
    boolean deferred = root.die(immediate);
    if (view != null) {
        view.assignParent(null);
        if (deferred) {
            mDyingViews.add(view);
        }
    }
}

// 更新
public void updateViewLayout(View view, ViewGroup.LayoutParams params) {
    ···
    final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;
    view.setLayoutParams(wparams);
    synchronized (mLock) {
        int index = findViewLocked(view, true);
        ViewRootImpl root = mRoots.get(index);
        mParams.remove(index);
        mParams.add(index, wparams);
        root.setLayoutParams(wparams, false);
    }
}
</code></pre>
<p>在 ViewRootImpl 中最终会通过 WindowSession 来完成 Window 的添加、更新、删除工作，mWindowSession 的类型是 IWindowSession，是一个 Binder 对象，真正地实现类是 Session，是一个 IPC 过程。</p>
<h2 id="window_2">Window 的创建过程</h2>
<h3 id="activity-window">Activity 的 Window 创建过程</h3>
<p>在 Activity 的创建过程中，最终会由 ActivityThread 的 performLaunchActivity() 来完成整个启动过程，该方法内部会通过类加载器创建 Activity 的实例对象，并调用 attach 方法关联一系列上下文环境变量。在 Activity 的 attach 方法里，系统会创建所属的 Window 对象并设置回调接口，然后在 Activity 的 setContentView 方法中将视图附属在 Window 上：</p>
<p><code>Activity.java</code></p>
<pre><code class="language-java">final void attach(Context context, ActivityThread aThread,
        Instrumentation instr, IBinder token, int ident,
        Application application, Intent intent, ActivityInfo info,
        CharSequence title, Activity parent, String id,
        NonConfigurationInstances lastNonConfigurationInstances,
        Configuration config, String referrer, IVoiceInteractor voiceInteractor,
        Window window, ActivityConfigCallback activityConfigCallback) {
    attachBaseContext(context);

    mFragments.attachHost(null /*parent*/);

    mWindow = new PhoneWindow(this, window, activityConfigCallback);
    mWindow.setWindowControllerCallback(this);
    mWindow.setCallback(this);
    mWindow.setOnWindowDismissedCallback(this);
    mWindow.getLayoutInflater().setPrivateFactory(this);
    if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
        mWindow.setSoftInputMode(info.softInputMode);
    }
    if (info.uiOptions != 0) {
        mWindow.setUiOptions(info.uiOptions);
    }
    ···
}
···

public void setContentView(@LayoutRes int layoutResID) {
    getWindow().setContentView(layoutResID);
    initWindowDecorActionBar();
}

</code></pre>
<p><code>PhoneWindow.java</code></p>
<pre><code class="language-java">@Override
public void setContentView(int layoutResID) {
    if (mContentParent == null) { // 如果没有 DecorView，就创建
        installDecor();
    } else {
        mContentParent.removeAllViews();
    }
    mLayoutInflater.inflate(layoutResID, mContentParent);
    final Callback cb = getCallback();
    if (cb != null &amp;&amp; !isDestroyed()) {
        // 回调 Activity 的 onContentChanged 方法通知 Activity 视图已经发生改变
        cb.onContentChanged();
    }
}
</code></pre>
<p>这个时候 DecorView 还没有被 WindowManager 正式添加。在 ActivityThread 的 handleResumeActivity 方法中，首先会调用 Activity 的 onResume 方法，接着调用 Activity 的 makeVisible()，完成 DecorView 的添加和显示过程：</p>
<p><code>Activity.java</code></p>
<pre><code class="language-java">void makeVisible() {
    if (!mWindowAdded) {
        ViewManager wm = getWindowManager();
        wm.addView(mDecor, getWindow().getAttributes());
        mWindowAdded = true;
    }
    mDecor.setVisibility(View.VISIBLE);
}
</code></pre>
<h3 id="dialog-window">Dialog 的 Window 创建过程</h3>
<p>Dialog 的 Window 的创建过程和 Activity 类似，创建同样是通过 PolicyManager 的 makeNewWindow 方法完成的，创建后的对象实际就是 PhoneWindow。当 Dialog 被关闭时，会通过 WindowManager 来移除 DecorView：mWindowManager.removeViewImmediate(mDecor)。</p>
<p><code>Dialog.java</code></p>
<pre><code class="language-java">Dialog(@NonNull Context context, @StyleRes int themeResId, boolean      createContextThemeWrapper) {
    ···
    mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);

    final Window w = new PhoneWindow(mContext);
    mWindow = w;
    w.setCallback(this);
    w.setOnWindowDismissedCallback(this);
    w.setOnWindowSwipeDismissedCallback(() -&gt; {
        if (mCancelable) {
            cancel();
        }
    });
    w.setWindowManager(mWindowManager, null, null);
    w.setGravity(Gravity.CENTER);

    mListenersHandler = new ListenersHandler(this);
}
</code></pre>
<p>普通 Dialog 必须采用 Activity 的 Context，采用 Application 的 Context 就会报错，是因为应用 token 所导致，应用 token 一般只有 Activity 拥有。系统 Window 比较特殊，不需要 token。</p>
<h3 id="toast-window">Toast 的 Window 创建过程</h3>
<p>Toast 属于系统 Window ，由于其具有定时取消功能，所以系统采用了 Handler。Toast 的内部有两类 IPC 过程，第一类是 Toast 访问 NotificationManagerService，第二类是 NotificationManagerService 回调 Toast 里的 TN 接口。</p>
<p>Toast 内部的视图由两种方式，一种是系统默认的样式，另一种是 setView 指定一个自定义 View，它们都对应 Toast 的一个内部成员 mNextView。</p>
<p><code>Toast.java</code></p>
<pre><code class="language-java">public void show() {
    if (mNextView == null) {
        throw new RuntimeException(&quot;setView must have been called&quot;);
    }

    INotificationManager service = getService();
    String pkg = mContext.getOpPackageName();
    TN tn = mTN;
    tn.mNextView = mNextView;

    try {
        service.enqueueToast(pkg, tn, mDuration);
    } catch (RemoteException e) {
        // Empty
    }
}
···

public void cancel() {
    mTN.cancel();
}

</code></pre>
<p><code>NotificationManagerService.java</code></p>
<pre><code class="language-java">private void showNextToastLocked() {
    ToastRecord record = mToastQueue.get(0);
    while (record != null) {
        if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback);
        try {
            record.callback.show();
            scheduleTimeoutLocked(record, false);
            return;
        } catch (RemoteException e) {
            Slog.w(TAG, &quot;Object died trying to show notification &quot; + record.callback
                    + &quot; in package &quot; + record.pkg);
            // remove it from the list and let the process die
            int index = mToastQueue.indexOf(record);
            if (index &gt;= 0) {
                mToastQueue.remove(index);
            }
            keepProcessAliveLocked(record.pid);
            if (mToastQueue.size() &gt; 0) {
                record = mToastQueue.get(0);
            } else {
                record = null;
            }
        }
    }
}

···
private void scheduleTimeoutLocked(ToastRecord r, boolean immediate)
{
    Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r);
    long delay = immediate ? 0 : (r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY);
    mHandler.removeCallbacksAndMessages(r);
    mHandler.sendMessageDelayed(m, delay);
}
</code></pre>
<h1 id="bitmap">Bitmap</h1>
<p><img alt="" src="https://upload-images.jianshu.io/upload_images/2618044-cd996dd172cce293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" /></p>
<h2 id="_22">配置信息与压缩方式</h2>
<p><strong>Bitmap 中有两个内部枚举类：</strong>
- Config 是用来设置颜色配置信息
- CompressFormat 是用来设置压缩方式</p>
<table>
<thead>
<tr>
<th>Config</th>
<th>单位像素所占字节数</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitmap.Config.ALPHA_8</td>
<td>1</td>
<td>颜色信息只由透明度组成，占8位</td>
</tr>
<tr>
<td>Bitmap.Config.ARGB_4444</td>
<td>2</td>
<td>颜色信息由rgba四部分组成，每个部分都占4位，总共占16位</td>
</tr>
<tr>
<td>Bitmap.Config.ARGB_8888</td>
<td>4</td>
<td>颜色信息由rgba四部分组成，每个部分都占8位，总共占32位。是Bitmap默认的颜色配置信息，也是最占空间的一种配置</td>
</tr>
<tr>
<td>Bitmap.Config.RGB_565</td>
<td>2</td>
<td>颜色信息由rgb三部分组成，R占5位，G占6位，B占5位，总共占16位</td>
</tr>
<tr>
<td>RGBA_F16</td>
<td>8</td>
<td>Android 8.0 新增（更丰富的色彩表现HDR）</td>
</tr>
<tr>
<td>HARDWARE</td>
<td>Special</td>
<td>Android 8.0 新增 （Bitmap直接存储在graphic memory）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>通常我们优化 Bitmap 时，当需要做性能优化或者防止 OOM，我们通常会使用 Bitmap.Config.RGB_565 这个配置，因为 Bitmap.Config.ALPHA_8 只有透明度，显示一般图片没有意义，Bitmap.Config.ARGB_4444 显示图片不清楚， Bitmap.Config.ARGB_8888 占用内存最多。</p>
</blockquote>
<table>
<thead>
<tr>
<th>CompressFormat</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitmap.CompressFormat.JPEG</td>
<td>表示以 JPEG 压缩算法进行图像压缩，压缩后的格式可以是 <code>.jpg</code> 或者 <code>.jpeg</code>，是一种有损压缩</td>
</tr>
<tr>
<td>Bitmap.CompressFormat.PNG</td>
<td>颜色信息由 rgba 四部分组成，每个部分都占 4 位，总共占 16 位</td>
</tr>
<tr>
<td>Bitmap.Config.ARGB_8888</td>
<td>颜色信息由 rgba 四部分组成，每个部分都占 8 位，总共占 32 位。是 Bitmap 默认的颜色配置信息，也是最占空间的一种配置</td>
</tr>
<tr>
<td>Bitmap.Config.RGB_565</td>
<td>颜色信息由 rgb 三部分组成，R 占 5 位，G 占 6 位，B 占 5 位，总共占 16 位</td>
</tr>
</tbody>
</table>
<h2 id="_23">常用操作</h2>
<h3 id="_24">裁剪、缩放、旋转、移动</h3>
<pre><code class="language-java">Matrix matrix = new Matrix();  
// 缩放 
matrix.postScale(0.8f, 0.9f);  
// 左旋，参数为正则向右旋
matrix.postRotate(-45);  
// 平移, 在上一次修改的基础上进行再次修改 set 每次操作都是最新的 会覆盖上次的操作
matrix.postTranslate(100, 80);
// 裁剪并执行以上操作
Bitmap bitmap = Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), matrix, true);
````
&gt; 虽然Matrix还可以调用postSkew方法进行倾斜操作，但是却不可以在此时创建Bitmap时使用。

### Bitmap与Drawable转换
```java
// Drawable -&gt; Bitmap
public static Bitmap drawableToBitmap(Drawable drawable) {
    Bitmap bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
    Canvas canvas = new Canvas(bitmap);
    drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight();
    drawable.draw(canvas);
    return bitmap;
}

// Bitmap -&gt; Drawable
public static Drawable bitmapToDrawable(Resources resources, Bitmap bm) {
    Drawable drawable = new BitmapDrawable(resources, bm);
    return drawable;
}
</code></pre>
<h3 id="_25">保存与释放</h3>
<pre><code class="language-java">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test);
File file = new File(getFilesDir(),&quot;test.jpg&quot;);
if(file.exists()){
    file.delete();
}
try {
    FileOutputStream outputStream=new FileOutputStream(file);
    bitmap.compress(Bitmap.CompressFormat.JPEG,90,outputStream);
    outputStream.flush();
    outputStream.close();
} catch (FileNotFoundException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
}
//释放bitmap的资源，这是一个不可逆转的操作
bitmap.recycle();
</code></pre>
<h3 id="_26">图片压缩</h3>
<pre><code class="language-java">public static Bitmap compressImage(Bitmap image) {
    if (image == null) {
        return null;
    }
    ByteArrayOutputStream baos = null;
    try {
        baos = new ByteArrayOutputStream();
        image.compress(Bitmap.CompressFormat.JPEG, 100, baos);
        byte[] bytes = baos.toByteArray();
        ByteArrayInputStream isBm = new ByteArrayInputStream(bytes);
        Bitmap bitmap = BitmapFactory.decodeStream(isBm);
        return bitmap;
    } catch (OutOfMemoryError e) {
        e.printStackTrace();
    } finally {
        try {
            if (baos != null) {
                baos.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return null;
}
</code></pre>
<h2 id="bitmapfactory">BitmapFactory</h2>
<h3 id="bitmap_1">Bitmap创建流程</h3>
<p><img alt="" src="https://upload-images.jianshu.io/upload_images/2618044-9c2046ca5054da05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" /></p>
<h3 id="option">Option类</h3>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean inJustDecodeBounds</td>
<td>如果设置为true，不获取图片，不分配内存，但会返回图片的高度宽度信息</td>
</tr>
<tr>
<td>int inSampleSize</td>
<td>图片缩放的倍数</td>
</tr>
<tr>
<td>int outWidth</td>
<td>获取图片的宽度值</td>
</tr>
<tr>
<td>int outHeight</td>
<td>获取图片的高度值</td>
</tr>
<tr>
<td>int inDensity</td>
<td>用于位图的像素压缩比</td>
</tr>
<tr>
<td>int inTargetDensity</td>
<td>用于目标位图的像素压缩比（要生成的位图）</td>
</tr>
<tr>
<td>byte[] inTempStorage</td>
<td>创建临时文件，将图片存储</td>
</tr>
<tr>
<td>boolean inScaled</td>
<td>设置为true时进行图片压缩，从inDensity到inTargetDensity</td>
</tr>
<tr>
<td>boolean inDither</td>
<td>如果为true,解码器尝试抖动解码</td>
</tr>
<tr>
<td>Bitmap.Config inPreferredConfig</td>
<td>设置解码器这个值是设置色彩模式，默认值是ARGB_8888，在这个模式下，一个像素点占用4bytes空间，一般对透明度不做要求的话，一般采用RGB_565模式，这个模式下一个像素点占用2bytes</td>
</tr>
<tr>
<td>String outMimeType</td>
<td>设置解码图像</td>
</tr>
<tr>
<td>boolean inPurgeable</td>
<td>当存储Pixel的内存空间在系统内存不足时是否可以被回收</td>
</tr>
<tr>
<td>boolean inInputShareable</td>
<td>inPurgeable为true情况下才生效，是否可以共享一个InputStream</td>
</tr>
<tr>
<td>boolean inPreferQualityOverSpeed</td>
<td>为true则优先保证Bitmap质量其次是解码速度</td>
</tr>
<tr>
<td>boolean inMutable</td>
<td>配置Bitmap是否可以更改，比如：在Bitmap上隔几个像素加一条线段</td>
</tr>
<tr>
<td>int inScreenDensity</td>
<td>当前屏幕的像素密度</td>
</tr>
</tbody>
</table>
<h3 id="_27">基本使用</h3>
<pre><code class="language-java">try {
    FileInputStream fis = new FileInputStream(filePath);
    BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    // 设置inJustDecodeBounds为true后，再使用decodeFile()等方法，并不会真正的分配空间，即解码出来的Bitmap为null，但是可计算出原始图片的宽度和高度，即options.outWidth和options.outHeight
    BitmapFactory.decodeFileDescriptor(fis.getFD(), null, options);
    float srcWidth = options.outWidth;
    float srcHeight = options.outHeight;
    int inSampleSize = 1;

    if (srcHeight &gt; height || srcWidth &gt; width) {
        if (srcWidth &gt; srcHeight) {
            inSampleSize = Math.round(srcHeight / height);
        } else {
            inSampleSize = Math.round(srcWidth / width);
        }
    }

    options.inJustDecodeBounds = false;
    options.inSampleSize = inSampleSize;

    return BitmapFactory.decodeFileDescriptor(fis.getFD(), null, options);
} catch (Exception e) {
    e.printStackTrace();
}
</code></pre>
<h2 id="_28">内存回收</h2>
<pre><code class="language-java">if(bitmap != null &amp;&amp; !bitmap.isRecycled()){ 
    // 回收并且置为null
    bitmap.recycle(); 
    bitmap = null; 
} 
</code></pre>
<p>Bitmap 类的构造方法都是私有的，所以开发者不能直接 new 出一个 Bitmap 对象，只能通过 BitmapFactory 类的各种静态方法来实例化一个 Bitmap。仔细查看 BitmapFactory 的源代码可以看到，生成 Bitmap 对象最终都是通过 JNI 调用方式实现的。所以，加载 Bitmap 到内存里以后，是包含两部分内存区域的。简单的说，一部分是Java 部分的，一部分是 C 部分的。这个 Bitmap 对象是由 Java 部分分配的，不用的时候系统就会自动回收了，但是那个对应的 C 可用的内存区域，虚拟机是不能直接回收的，这个只能调用底层的功能释放。所以需要调用 recycle() 方法来释放 C 部分的内存。从 Bitmap 类的源代码也可以看到，recycle() 方法里也的确是调用了 JNI 方法了的。</p>
<h1 id="_29">屏幕适配</h1>
<h2 id="_30">单位</h2>
<ul>
<li>
<p>dpi
每英寸像素数(dot per inch)  </p>
</li>
<li>
<p>dp<br />
密度无关像素 - 一种基于屏幕物理密度的抽象单元。 这些单位相对于 160 dpi 的屏幕，因此一个 dp 是 160 dpi 屏幕上的一个 px。 dp 与像素的比率将随着屏幕密度而变化，但不一定成正比。为不同设备的 UI 元素的实际大小提供了一致性。</p>
</li>
<li>
<p>sp<br />
与比例无关的像素 - 这与 dp 单位类似，但它也可以通过用户的字体大小首选项进行缩放。建议在指定字体大小时使用此单位，以便根据屏幕密度和用户偏好调整它们。</p>
</li>
</ul>
<pre><code>dpi = px / inch

density = dpi / 160

dp = px / density
</code></pre>
<h2 id="_31">头条适配方案</h2>
<pre><code class="language-java">private static void setCustomDensity(@NonNull Activity activity, @NonNull final Application application) {
    final DisplayMetrics appDisplayMetrics = application.getResources().getDisplayMetrics();
    if (sNoncompatDensity == 0) {
        sNoncompatDensity = appDisplayMetrics.density;
        sNoncompatScaledDensity = appDisplayMetrics.scaledDensity;
        // 监听字体切换
        application.registerComponentCallbacks(new ComponentCallbacks() {
            @Override
            public void onConfigurationChanged(Configuration newConfig) {
                if (newConfig != null &amp;&amp; newConfig.fontScale &gt; 0) {
                    sNoncompatScaledDensity = application.getResources().getDisplayMetrics().scaledDensity;
                }
            }

            @Override
            public void onLowMemory() {

            }
        });
    }

    // 适配后的dpi将统一为360dpi
    final float targetDensity = appDisplayMetrics.widthPixels / 360;
    final float targetScaledDensity = targetDensity * (sNoncompatScaledDensity / sNoncompatDensity);
    final int targetDensityDpi = (int)(160 * targetDensity);

    appDisplayMetrics.density = targetDensity;
    appDisplayMetrics.scaledDensity = targetScaledDensity;
    appDisplayMetrics.densityDpi = targetDensityDpi;

    final DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics();
    activityDisplayMetrics.density = targetDensity;
    activityDisplayMetrics.scaledDensity = targetScaledDensity;
    activityDisplayMetrics.densityDpi = targetDensityDpi
}
</code></pre>
<h2 id="_32">刘海屏适配</h2>
<ul>
<li>Android P 刘海屏适配方案</li>
</ul>
<p>Android P 支持最新的全面屏以及为摄像头和扬声器预留空间的凹口屏幕。通过全新的 DisplayCutout 类，可以确定非功能区域的位置和形状，这些区域不应显示内容。要确定这些凹口屏幕区域是否存在及其位置，使用 getDisplayCutout() 函数。</p>
<table>
<thead>
<tr>
<th>DisplayCutout 类方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getBoundingRects()</td>
<td>返回Rects的列表，每个Rects都是显示屏上非功能区域的边界矩形</td>
</tr>
<tr>
<td>getSafeInsetLeft ()</td>
<td>返回安全区域距离屏幕左边的距离，单位是px</td>
</tr>
<tr>
<td>getSafeInsetRight ()</td>
<td>返回安全区域距离屏幕右边的距离，单位是px</td>
</tr>
<tr>
<td>getSafeInsetTop ()</td>
<td>返回安全区域距离屏幕顶部的距离，单位是px</td>
</tr>
<tr>
<td>getSafeInsetBottom()</td>
<td>返回安全区域距离屏幕底部的距离，单位是px</td>
</tr>
</tbody>
</table>
<p>Android P 中 WindowManager.LayoutParams 新增了一个布局参数属性 layoutInDisplayCutoutMode：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>模式说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT</td>
<td>只有当DisplayCutout完全包含在系统栏中时，才允许窗口延伸到DisplayCutout区域。 否则，窗口布局不与DisplayCutout区域重叠。</td>
</tr>
<tr>
<td>LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER</td>
<td>该窗口决不允许与DisplayCutout区域重叠。</td>
</tr>
<tr>
<td>LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES</td>
<td>该窗口始终允许延伸到屏幕短边上的DisplayCutout区域。</td>
</tr>
</tbody>
</table>
<ul>
<li>Android P 之前的刘海屏适配</li>
</ul>
<p>不同厂商的刘海屏适配方案不尽相同，需分别查阅各自的开发者文档。</p>
<h1 id="context">Context</h1>
<p>Context 本身是一个抽象类，是对一系列系统服务接口的封装，包括：内部资源、包、类加载、I/O操作、权限、主线程、IPC 和组件启动等操作的管理。ContextImpl, Activity, Service, Application 这些都是 Context 的直接或间接子类, 关系如下:</p>
<p><img alt="" src="http://gityuan.com/images/context/context.jpg" /></p>
<p>ContextWrapper是代理Context的实现，简单地将其所有调用委托给另一个Context（mBase）。</p>
<p>Application、Activity、Service通过<code>attach()</code>调用父类ContextWrapper的<code>attachBaseContext()</code>, 从而设置父类成员变量 mBase 为 ContextImpl 对象, ContextWrapper 的核心工作都是交给 mBase(ContextImpl) 来完成，这样可以子类化 Context 以修改行为而无需更改原始 Context。</p>
<h1 id="sharedpreferences">SharedPreferences</h1>
<p>SharedPreferences 采用key-value（键值对）形式, 主要用于轻量级的数据存储, 尤其适合保存应用的配置参数, 但不建议使用 SharedPreferences 来存储大规模的数据, 可能会降低性能.</p>
<p>SharedPreferences采用xml文件格式来保存数据, 该文件所在目录位于 <code>/data/data/&lt;package name&gt;/shared_prefs</code>，如：</p>
<pre><code class="language-xml">&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;
&lt;map&gt;
   &lt;string name=&quot;blog&quot;&gt;https://github.com/JasonWu1111/Android-Review&lt;/string&gt;
&lt;/map&gt;
</code></pre>
<p>从Android N开始, 创建的 SP 文件模式, 不允许 <code>MODE_WORLD_READABLE</code> 和 <code>MODE_WORLD_WRITEABLE</code> 模块, 否则会直接抛出异常 SecurityException。 <code>MODE_MULTI_PROCESS</code> 这种多进程的方式也是 Google 不推荐的方式, 后续同样会不再支持。</p>
<p>当设置 MODE_MULTI_PROCESS 模式, 则每次 getSharedPreferences 过程, 会检查 SP 文件上次修改时间和文件大小, 一旦所有修改则会重新从磁盘加载文件。</p>
<h2 id="_33">获取方式</h2>
<h3 id="getpreferences">getPreferences</h3>
<p>Activity.getPreferences(mode): 以当前 Activity 的类名作为 SP 的文件名. 即 xxxActivity.xml
<code>Activity.java</code></p>
<pre><code class="language-java">public SharedPreferences getPreferences(int mode) {
    return getSharedPreferences(getLocalClassName(), mode);
}
</code></pre>
<h3 id="getdefaultsharedpreferences">getDefaultSharedPreferences</h3>
<p>PreferenceManager.getDefaultSharedPreferences(Context): 以包名加上 _preferences 作为文件名, 以 MODE_PRIVATE 模式创建 SP 文件. 即 packgeName_preferences.xml.</p>
<pre><code class="language-java">public static SharedPreferences getDefaultSharedPreferences(Context context) {
    return context.getSharedPreferences(getDefaultSharedPreferencesName(context),
           getDefaultSharedPreferencesMode());
}
</code></pre>
<h3 id="getsharedpreferences">getSharedPreferences</h3>
<p>直接调用 Context.getSharedPreferences(name, mode)，所有的方法最终都是调用到如下方法：</p>
<pre><code class="language-java">class ContextImpl extends Context {
    private ArrayMap&lt;String, File&gt; mSharedPrefsPaths;

    public SharedPreferences getSharedPreferences(String name, int mode) {
        File file;
        synchronized (ContextImpl.class) {
            if (mSharedPrefsPaths == null) {
                mSharedPrefsPaths = new ArrayMap&lt;&gt;();
            }
            //先从mSharedPrefsPaths查询是否存在相应文件
            file = mSharedPrefsPaths.get(name);
            if (file == null) {
                //如果文件不存在, 则创建新的文件 
                file = getSharedPreferencesPath(name);
                mSharedPrefsPaths.put(name, file);
            }
        }

        return getSharedPreferences(file, mode);
    }
}
</code></pre>
<h2 id="_34">架构</h2>
<p><img alt="" src="http://gityuan.com/images/sp/shared_preference.jpg" /></p>
<p>SharedPreferences 与 Editor 只是两个接口. SharedPreferencesImpl 和 EditorImpl 分别实现了对应接口。另外, ContextImpl 记录着 SharedPreferences 的重要数据。</p>
<p><code>putxxx()</code> 操作把数据写入到EditorImpl.mModified；</p>
<p><code>apply()/commit()</code> 操作先调用 commitToMemory(), 将数据同步到 SharedPreferencesImpl 的 mMap, 并保存到 MemoryCommitResult 的 mapToWriteToDisk，再调用 enqueueDiskWrite(), 写入到磁盘文件; 先之前把原有数据保存到 .bak 为后缀的文件,用于在写磁盘的过程出现任何异常可恢复数据;</p>
<p><code>getxxx()</code> 操作从 SharedPreferencesImpl.mMap 读取数据.</p>
<h2 id="apply-commit">apply / commit</h2>
<ul>
<li>apply 没有返回值, commit 有返回值能知道修改是否提交成功  </li>
<li>apply 是将修改提交到内存，再异步提交到磁盘文件，而 commit 是同步的提交到磁盘文件</li>
<li>多并发的提交 commit 时，需等待正在处理的 commit 数据更新到磁盘文件后才会继续往下执行，从而降低效率; 而 apply 只是原子更新到内存，后调用 apply 函数会直接覆盖前面内存数据，从一定程度上提高很多效率。</li>
</ul>
<h2 id="_35">注意</h2>
<ul>
<li>强烈建议不要在 sp 里面存储特别大的 key/value，有助于减少卡顿 / anr</li>
<li>不要高频地使用 apply，尽可能地批量提交</li>
<li>不要使用 MODE_MULTI_PROCESS</li>
<li>高频写操作的 key 与高频读操作的 key 可以适当地拆分文件，由于减少同步锁竞争</li>
<li>不要连续多次 edit()，应该获取一次获取 edit()，然后多次执行 putxxx()，减少内存波动</li>
</ul>
<h1 id="_36">消息机制</h1>
<h2 id="handler">Handler 机制</h2>
<p>Handler 有两个主要用途：（1）安排 Message 和 runnables 在将来的某个时刻执行; （2）将要在不同于自己的线程上执行的操作排入队列。(在多个线程并发更新UI的同时保证线程安全。)</p>
<p>Android 规定访问 UI 只能在主线程中进行，因为 Android 的 UI 控件不是线程安全的，多线程并发访问会导致 UI 控件处于不可预期的状态。为什么系统不对 UI 控件的访问加上锁机制？缺点有两个：加锁会让 UI 访问的逻辑变得复杂；其次锁机制会降低 UI 访问的效率。如果子线程访问 UI，那么程序就会抛出异常。ViewRootImpl 对UI操作做了验证，这个验证工作是由 ViewRootImpl的 <code>checkThread</code> 方法完成：</p>
<p><code>ViewRootImpl.java</code></p>
<pre><code class="language-java">void checkThread() {
    if (mThread != Thread.currentThread()) {
        throw new CalledFromWrongThreadException(
                &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);
    }
}
</code></pre>
<ul>
<li>Message：Handler 接收和处理的消息对象</li>
<li>MessageQueue：Message 的队列，先进先出，每一个线程最多可以拥有一个</li>
<li>Looper：消息泵，是 MessageQueue 的管理者，会不断从 MessageQueue 中取出消息，并将消息分给对应的 Handler 处理，每个线程只有一个 Looper。</li>
</ul>
<p>Handler 创建的时候会采用当前线程的 Looper 来构造消息循环系统，需要注意的是，线程默认是没有 Looper 的，直接使用 Handler 会报错，如果需要使用 Handler 就必须为线程创建 Looper，因为默认的 UI 主线程，也就是 ActivityThread，ActivityThread 被创建的时候就会初始化 Looper，这也是在主线程中默认可以使用 Handler 的原因。</p>
<h2 id="_37">工作原理</h2>
<h3 id="threadlocal">ThreadLocal</h3>
<p>ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，其他线程则无法获取。Looper、ActivityThread 以及 AMS 中都用到了 ThreadLocal。当不同线程访问同一个ThreadLocal 的 get方法，ThreadLocal 内部会从各自的线程中取出一个数组，然后再从数组中根据当前 ThreadLcoal 的索引去查找对应的value值。
<code>ThreadLocal.java</code></p>
<pre><code class="language-java">public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}

···
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
</code></pre>
<h3 id="messagequeue">MessageQueue</h3>
<p>MessageQueue主要包含两个操作：插入和读取。读取操作本身会伴随着删除操作，插入和读取对应的方法分别是 <code>enqueueMessage</code> 和 <code>next</code>。MessageQueue 内部实现并不是用的队列，实际上通过一个单链表的数据结构来维护消息列表。next 方法是一个无限循环的方法，如果消息队列中没有消息，那么 next 方法会一直阻塞。当有新消息到来时，next 方法会放回这条消息并将其从单链表中移除。</p>
<p><code>MessageQueue.java</code></p>
<pre><code class="language-java">boolean enqueueMessage(Message msg, long when) {
    ···
    synchronized (this) {
        ···
        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when &lt; p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when &lt; p.when) {
                    break;
                }
                if (needWake &amp;&amp; p.isAsynchronous()) {
                    needWake = false;
                }
            }
            msg.next = p; // invariant: p == prev.next
            prev.next = msg;
        }

        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}
···
Message next() {
    // Return here if the message loop has already quit and been disposed.
    // This can happen if the application tries to restart a looper after quit
    // which is not supported.
    ···
    for (;;) {
        ···
        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null &amp;&amp; msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now &lt; msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }
            ···
        }

        // Run the idle handlers.
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; // release the reference to the handler

            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
            }

            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }

        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;

        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}
</code></pre>
<h3 id="looper">Looper</h3>
<p>Looper 会不停地从 MessageQueue 中 查看是否有新消息，如果有新消息就会立刻处理，否则会一直阻塞。
<code>Looper.java</code></p>
<pre><code class="language-java">private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}
</code></pre>
<p>可通过 Looper.prepare() 为当前线程创建一个 Looper：</p>
<pre><code class="language-java">new Thread(&quot;Thread#2&quot;) {
    @Override
    public void run() {
        Looper.prepare();
        Handler handler = new Handler();
        Looper.loop();
    }
}.start();
</code></pre>
<p>除了 prepare 方法外，Looper 还提供了 <code>prepareMainLooper</code> 方法，主要是给 ActivityThread 创建 Looper 使用，本质也是通过 prepare 方法实现的。由于主线程的 Looper 比较特殊，所以 Looper 提供了一个 getMainLooper 方法来获取主线程的 Looper。</p>
<p>Looper 提供了 <code>quit</code> 和 <code>quitSafely</code> 来退出一个 Looper，二者的区别是：<code>quit</code> 会直接退出 Looper，而 <code>quitSafly</code> 只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全地退出。Looper 退出后，通过 Handler 发送的消息会失败，这个时候 Handler 的 send 方法会返回 false。因此在不需要的时候应终止 Looper。</p>
<p><code>Looper.java</code></p>
<pre><code class="language-java">public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue;
    ···
    for (;;) {
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        ···
        try {
            msg.target.dispatchMessage(msg);
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        ···
        msg.recycleUnchecked();
    }
}
</code></pre>
<p>loop 方法是一个死循环，唯一跳出循环的方式是 MessageQueue 的 next 方法返回了null。当 Looper 的 quit 方法被调用时，Looper就会调用 MessageQueue 的 quit 或者 qutiSafely 方法来通知消息队列退出，当消息队列被标记为退出状态时，它的 next 方法就会返回 null。loop 方法会调用 MessageQueue 的 next 方法来获取新消息，而 next 是一个阻塞操作，当没有消息时，next 会一直阻塞，导致 loop 方法一直阻塞。Looper 处理这条消息： msg.target.dispatchMessage(msg)，这里的 msg.target 是发送这条消息的 Handler 对象。</p>
<h3 id="handler_1">Handler</h3>
<p>Handler 的工作主要包含消息的发送和接收的过程。消息的发送可以通过 post/send 的一系列方法实现，post 最终也是通过send来实现的。</p>
<p><img alt="" src="https://img-blog.csdnimg.cn/20181220142659447" /></p>
<h1 id="_38">线程异步</h1>
<p>线程（thread） 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p>
<p>应用启动时，系统会为应用创建一个名为“主线程”的执行线程( UI 线程)。 此线程非常重要，因为它负责将事件分派给相应的用户界面小部件，其中包括绘图事件。 此外，它也是应用与 Android UI 工具包组件（来自 <code>android.widget</code> 和 <code>android.view</code> 软件包的组件）进行交互的线程。</p>
<p>系统不会为每个组件实例创建单独的线程。运行于同一进程的所有组件均在 UI 线程中实例化，并且对每个组件的系统调用均由该线程进行分派。 因此，响应系统回调的方法（例如，报告用户操作的 onKeyDown() 或生命周期回调方法）始终在进程的 UI 线程中运行。</p>
<p>Android 的单线程模式必须遵守两条规则:
- 不要阻塞 UI 线程
- 不要在 UI 线程之外访问 Android UI 工具包</p>
<p>为解决此问题，Android 提供了几种途径来从其他线程访问 UI 线程:
- <code>Activity.runOnUiThread(Runnable)</code>
- <code>View.post(Runnable)</code>
- <code>View.postDelayed(Runnable, long)</code></p>
<h2 id="asynctask">AsyncTask</h2>
<p>AsyncTask 封装了 Thread 和 Handler，并不适合特别耗时的后台任务，对于特别耗时的任务来说，建议使用线程池。</p>
<h3 id="_39">基本使用</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>onPreExecute()</td>
<td>异步任务执行前调用，用于做一些准备工作</td>
</tr>
<tr>
<td>doInBackground(Params...params)</td>
<td>用于执行异步任务，此方法中可以通过 publishProgress 方法来更新任务的进度，publishProgress 会调用 onProgressUpdate 方法</td>
</tr>
<tr>
<td>onProgressUpdate</td>
<td>在主线程中执行，后台任务的执行进度发生改变时调用</td>
</tr>
<tr>
<td>onPostExecute</td>
<td>在主线程中执行，在异步任务执行之后</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">import android.os.AsyncTask;

public class DownloadTask extends AsyncTask&lt;String, Integer, Boolean&gt; {

    @Override
    protected void onPreExecute() {
        super.onPreExecute();
    }

    @Override
    protected Boolean doInBackground(String... strings) {
        return null;
    }

    @Override
    protected void onProgressUpdate(Integer... values) {
        super.onProgressUpdate(values);
    }

    @Override
    protected void onPostExecute(Boolean aBoolean) {
        super.onPostExecute(aBoolean);
    }
}
</code></pre>
<ul>
<li>异步任务的实例必须在 UI 线程中创建，即 AsyncTask 对象必须在UI线程中创建。</li>
<li>execute(Params... params)方法必须在UI线程中调用。</li>
<li>不要手动调用 onPreExecute()，doInBackground()，onProgressUpdate()，onPostExecute() 这几个方法。</li>
<li>不能在 doInBackground() 中更改UI组件的信息。</li>
<li>一个任务实例只能执行一次，如果执行第二次将会抛出异常。</li>
<li>execute() 方法会让同一个进程中的 AsyncTask 串行执行，如果需要并行，可以调用 executeOnExcutor 方法。</li>
</ul>
<h3 id="_40">工作原理</h3>
<p><code>AsyncTask.java</code></p>
<pre><code class="language-java">@MainThread
public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {
    return executeOnExecutor(sDefaultExecutor, params);
}

@MainThread
public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,
        Params... params) {
    if (mStatus != Status.PENDING) {
        switch (mStatus) {
            case RUNNING:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task is already running.&quot;);
            case FINISHED:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task has already been executed &quot;
                        + &quot;(a task can be executed only once)&quot;);
        }
    }

    mStatus = Status.RUNNING;

    onPreExecute();

    mWorker.mParams = params;
    exec.execute(mFuture);

    return this;
}
</code></pre>
<p>sDefaultExecutor 是一个串行的线程池，一个进程中的所有的 AsyncTask 全部在该线程池中执行。AysncTask 中有两个线程池（SerialExecutor 和 THREAD_POOL_EXECUTOR）和一个 Handler（InternalHandler），其中线程池 SerialExecutor 用于任务的排队，THREAD_POOL_EXECUTOR 用于真正地执行任务，InternalHandler 用于将执行环境从线程池切换到主线程。</p>
<p><code>AsyncTask.java</code></p>
<pre><code class="language-java">private static Handler getMainHandler() {
    synchronized (AsyncTask.class) {
        if (sHandler == null) {
            sHandler = new InternalHandler(Looper.getMainLooper());
        }
        return sHandler;
    }
}

private static class InternalHandler extends Handler {
    public InternalHandler(Looper looper) {
        super(looper);
    }

    @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;})
    @Override
    public void handleMessage(Message msg) {
        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;
        switch (msg.what) {
            case MESSAGE_POST_RESULT:
                // There is only one result
                result.mTask.finish(result.mData[0]);
                break;
            case MESSAGE_POST_PROGRESS:
                result.mTask.onProgressUpdate(result.mData);
                break;
        }
    }
}


private Result postResult(Result result) {
    @SuppressWarnings(&quot;unchecked&quot;)
    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,
            new AsyncTaskResult&lt;Result&gt;(this, result));
    message.sendToTarget();
    return result;
}
</code></pre>
<h2 id="handlerthread">HandlerThread</h2>
<p>HandlerThread 集成了 Thread，却和普通的 Thread 有显著的不同。普通的 Thread 主要用于在 run 方法中执行一个耗时任务，而 HandlerThread 在内部创建了消息队列，外界需要通过 Handler 的消息方式通知 HanderThread 执行一个具体的任务。</p>
<p><code>HandlerThread.java</code></p>
<pre><code class="language-java">@Override
public void run() {
    mTid = Process.myTid();
    Looper.prepare();
    synchronized (this) {
        mLooper = Looper.myLooper();
        notifyAll();
    }
    Process.setThreadPriority(mPriority);
    onLooperPrepared();
    Looper.loop();
    mTid = -1;
}
</code></pre>
<h2 id="intentservice">IntentService</h2>
<p>IntentService 可用于执行后台耗时的任务，当任务执行后会自动停止，由于其是 Service 的原因，它的优先级比单纯的线程要高，所以 IntentService 适合执行一些高优先级的后台任务。在实现上，IntentService 封装了 HandlerThread 和 Handler。</p>
<p><code>IntentService.java</code></p>
<pre><code class="language-java">@Override
public void onCreate() {
    // TODO: It would be nice to have an option to hold a partial wakelock
    // during processing, and to have a static startService(Context, Intent)
    // method that would launch the service &amp; hand off a wakelock.

    super.onCreate();
    HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);
    thread.start();

    mServiceLooper = thread.getLooper();
    mServiceHandler = new ServiceHandler(mServiceLooper);
}
</code></pre>
<p>IntentService 第一次启动时，会在 onCreatea 方法中创建一个 HandlerThread，然后使用的 Looper 来构造一个 Handler 对象 mServiceHandler，这样通过 mServiceHandler 发送的消息最终都会在 HandlerThread 中执行。每次启动 IntentService，它的 onStartCommand 方法就会调用一次，onStartCommand 中处理每个后台任务的 Intent，onStartCommand 调用了 onStart 方法：</p>
<p><code>IntentService.java</code></p>
<pre><code class="language-java">private final class ServiceHandler extends Handler {
    public ServiceHandler(Looper looper) {
        super(looper);
    }

    @Override
    public void handleMessage(Message msg) {
        onHandleIntent((Intent)msg.obj);
        stopSelf(msg.arg1);
    }
}

···

@Override
public void onStart(@Nullable Intent intent, int startId) {
    Message msg = mServiceHandler.obtainMessage();
    msg.arg1 = startId;
    msg.obj = intent;
    mServiceHandler.sendMessage(msg);
}
</code></pre>
<p>可以看出，IntentService 仅仅是通过 mServiceHandler 发送了一个消息，这个消息会在 HandlerThread 中被处理。mServiceHandler 收到消息后，会将 Intent 对象传递给 onHandlerIntent 方法中处理，执行结束后，通过 stopSelf(int startId) 来尝试停止服务。（stopSelf() 会立即停止服务，而 stopSelf(int startId) 则会等待所有的消息都处理完毕后才终止服务）。</p>
<h2 id="_41">线程池</h2>
<p>线程池的优点有以下：
- 重用线程池中的线程，避免因为线程的创建和销毁带来性能开销。
- 能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象。
- 能够对线程进行管理，并提供定时执行以及定间隔循环执行等功能。</p>
<p>java 中，ThreadPoolExecutor 是线程池的真正实现：</p>
<p><code>ThreadPoolExecutor.java</code></p>
<pre><code class="language-java">/**
    * Creates a new {@code ThreadPoolExecutor} with the given initial
    * parameters.
    *
    * @param corePoolSize 核心线程数
    * @param maximumPoolSize 最大线程数
    * @param keepAliveTime 非核心线程闲置的超时时长
    * @param unit 用于指定 keepAliveTime 参数的时间单位
    * @param 任务队列，通过线程池的 execute 方法提交的 Runnable 对象会存储在这个参数中
    * @param threadFactory 线程工厂，用于创建新线程
    * @param handler 任务队列已满或者是无法成功执行任务时调用
    */
public ThreadPoolExecutor(int corePoolSize,
                            int maximumPoolSize,
                            long keepAliveTime,
                            TimeUnit unit,
                            BlockingQueue&lt;Runnable&gt; workQueue,
                            ThreadFactory threadFactory,
                            RejectedExecutionHandler handler) {
    ···
}
</code></pre>
<table>
<thead>
<tr>
<th>类型</th>
<th>创建方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>FixedThreadPool</td>
<td>Executors.newFixedThreadPool(int nThreads)</td>
<td>一种线程数量固定的线程池，只有核心线程并且不会被回收，没有超时机制</td>
</tr>
<tr>
<td>CachedThreadPool</td>
<td>Executors.newCachedThreadPool()</td>
<td>一种线程数量不定的线程池，只有非核心线程，当线程都处于活动状态时，会创建新线程来处理新任务，否则会利用空闲的线程，超时时长为60s</td>
</tr>
<tr>
<td>ScheduledThreadPool</td>
<td>Executors.newScheduledThreadPool(int corePoolSize)</td>
<td>核心线程数是固定的，非核心线程数没有限制，非核心线程闲置时立刻回收，主要用于执行定时任务和固定周期的重复任务</td>
</tr>
<tr>
<td>SingleThreadExecutor</td>
<td>Executors.newSingleThreadExecutor()</td>
<td>只有一个核心线程，确保所有任务在同一线程中按顺序执行</td>
</tr>
</tbody>
</table>
<h1 id="recyclerview">RecyclerView 优化</h1>
<ul>
<li>
<p>数据处理和视图加载分离：数据的处理逻辑尽可能放在异步处理，onBindViewHolder 方法中只处理数据填充到视图中。</p>
</li>
<li>
<p>数据优化：分页拉取远端数据，对拉取下来的远端数据进行缓存，提升二次加载速度；对于新增或者删除数据通过 DiffUtil 来进行局部刷新数据，而不是一味地全局刷新数据。</p>
</li>
</ul>
<p>示例</p>
<pre><code class="language-java">public class AdapterDiffCallback extends DiffUtil.Callback {

    private List&lt;String&gt; mOldList;
    private List&lt;String&gt; mNewList;

    public AdapterDiffCallback(List&lt;String&gt; oldList, List&lt;String&gt; newList) {
        mOldList = oldList;
        mNewList = newList;
        DiffUtil.DiffResult
    }

    @Override
    public int getOldListSize() {
        return mOldList.size();
    }

    @Override
    public int getNewListSize() {
        return mNewList.size();
    }

    @Override
    public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) {
        return mOldList.get(oldItemPosition).getClass().equals(mNewList.get(newItemPosition).getClass());
    }

    @Override
    public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) {
        return mOldList.get(oldItemPosition).equals(mNewList.get(newItemPosition));
    }
}
</code></pre>
<pre><code class="language-java">DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new AdapterDiffCallback(oldList, newList));
diffResult.dispatchUpdatesTo(mAdapter);
</code></pre>
<ul>
<li>
<p>布局优化：减少布局层级，简化 ItemView</p>
</li>
<li>
<p>升级 RecycleView 版本到 25.1.0 及以上使用 Prefetch 功能</p>
</li>
<li>
<p>通过重写 RecyclerView.onViewRecycled(holder) 来回收资源</p>
</li>
<li>
<p>如果 Item 高度是固定的话，可以使用 RecyclerView.setHasFixedSize(true); 来避免 requestLayout 浪费资源</p>
</li>
<li>
<p>对 ItemView 设置监听器，不要对每个 Item 都调用 addXxListener，应该大家公用一个 XxListener，根据 ID 来进行不同的操作，优化了对象的频繁创建带来的资源消耗</p>
</li>
<li>
<p>如果多个 RecycledView 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 RecyclerView.setRecycledViewPool(pool)，来共用一个 RecycledViewPool。</p>
</li>
</ul>
<h1 id="webview">Webview</h1>
<h2 id="_42">基本使用</h2>
<h3 id="webview_1">WebView</h3>
<pre><code class="language-java">// 获取当前页面的URL
public String getUrl();
// 获取当前页面的原始URL(重定向后可能当前url不同)
// 就是http headers的Referer参数，loadUrl时为null
public String getOriginalUrl();
// 获取当前页面的标题
public String getTitle();
// 获取当前页面的favicon
public Bitmap getFavicon();
// 获取当前页面的加载进度
public int getProgress();

// 通知WebView内核网络状态
// 用于设置JS属性`window.navigator.isOnline`和产生HTML5事件`online/offline`
public void setNetworkAvailable(boolean networkUp)

// 设置初始缩放比例
public void setInitialScale(int scaleInPercent)；

</code></pre>
<h3 id="websettings">WebSettings</h3>
<pre><code class="language-java">WebSettings settings = web.getSettings();

// 存储(storage)
// 启用HTML5 DOM storage API，默认值 false
settings.setDomStorageEnabled(true); 
// 启用Web SQL Database API，这个设置会影响同一进程内的所有WebView，默认值 false
// 此API已不推荐使用，参考：https://www.w3.org/TR/webdatabase/
settings.setDatabaseEnabled(true);  
// 启用Application Caches API，必需设置有效的缓存路径才能生效，默认值 false
// 此API已废弃，参考：https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache
settings.setAppCacheEnabled(true); 
settings.setAppCachePath(context.getCacheDir().getAbsolutePath());

// 定位(location)
settings.setGeolocationEnabled(true);

// 是否保存表单数据
settings.setSaveFormData(true);
// 是否当webview调用requestFocus时为页面的某个元素设置焦点，默认值 true
settings.setNeedInitialFocus(true);  

// 是否支持viewport属性，默认值 false
// 页面通过`&lt;meta name=&quot;viewport&quot; ... /&gt;`自适应手机屏幕
settings.setUseWideViewPort(true);
// 是否使用overview mode加载页面，默认值 false
// 当页面宽度大于WebView宽度时，缩小使页面宽度等于WebView宽度
settings.setLoadWithOverviewMode(true);
// 布局算法
settings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.NORMAL);

// 是否支持Javascript，默认值false
settings.setJavaScriptEnabled(true); 
// 是否支持多窗口，默认值false
settings.setSupportMultipleWindows(false);
// 是否可用Javascript(window.open)打开窗口，默认值 false
settings.setJavaScriptCanOpenWindowsAutomatically(false);

// 资源访问
settings.setAllowContentAccess(true); // 是否可访问Content Provider的资源，默认值 true
settings.setAllowFileAccess(true);    // 是否可访问本地文件，默认值 true
// 是否允许通过file url加载的Javascript读取本地文件，默认值 false
settings.setAllowFileAccessFromFileURLs(false);  
// 是否允许通过file url加载的Javascript读取全部资源(包括文件,http,https)，默认值 false
settings.setAllowUniversalAccessFromFileURLs(false);

// 资源加载
settings.setLoadsImagesAutomatically(true); // 是否自动加载图片
settings.setBlockNetworkImage(false);       // 禁止加载网络图片
settings.setBlockNetworkLoads(false);       // 禁止加载所有网络资源

// 缩放(zoom)
settings.setSupportZoom(true);          // 是否支持缩放
settings.setBuiltInZoomControls(false); // 是否使用内置缩放机制
settings.setDisplayZoomControls(true);  // 是否显示内置缩放控件

// 默认文本编码，默认值 &quot;UTF-8&quot;
settings.setDefaultTextEncodingName(&quot;UTF-8&quot;);
settings.setDefaultFontSize(16);        // 默认文字尺寸，默认值16，取值范围1-72
settings.setDefaultFixedFontSize(16);   // 默认等宽字体尺寸，默认值16
settings.setMinimumFontSize(8);         // 最小文字尺寸，默认值 8
settings.setMinimumLogicalFontSize(8);  // 最小文字逻辑尺寸，默认值 8
settings.setTextZoom(100);              // 文字缩放百分比，默认值 100

// 字体
settings.setStandardFontFamily(&quot;sans-serif&quot;);   // 标准字体，默认值 &quot;sans-serif&quot;
settings.setSerifFontFamily(&quot;serif&quot;);           // 衬线字体，默认值 &quot;serif&quot;
settings.setSansSerifFontFamily(&quot;sans-serif&quot;);  // 无衬线字体，默认值 &quot;sans-serif&quot;
settings.setFixedFontFamily(&quot;monospace&quot;);       // 等宽字体，默认值 &quot;monospace&quot;
settings.setCursiveFontFamily(&quot;cursive&quot;);       // 手写体(草书)，默认值 &quot;cursive&quot;
settings.setFantasyFontFamily(&quot;fantasy&quot;);       // 幻想体，默认值 &quot;fantasy&quot;


if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
    // 用户是否需要通过手势播放媒体(不会自动播放)，默认值 true
    settings.setMediaPlaybackRequiresUserGesture(true);
}
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {
    // 5.0以上允许加载http和https混合的页面(5.0以下默认允许，5.0+默认禁止)
    settings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);
}
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
    // 是否在离开屏幕时光栅化(会增加内存消耗)，默认值 false
    settings.setOffscreenPreRaster(false);
}

if (isNetworkConnected(context)) {
    // 根据cache-control决定是否从网络上取数据
    settings.setCacheMode(WebSettings.LOAD_DEFAULT);
} else {
    // 没网，离线加载，优先加载缓存(即使已经过期)
    settings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);
}

// deprecated
settings.setRenderPriority(WebSettings.RenderPriority.HIGH);
settings.setDatabasePath(context.getDir(&quot;database&quot;, Context.MODE_PRIVATE).getPath());
settings.setGeolocationDatabasePath(context.getFilesDir().getPath());

</code></pre>
<h3 id="webviewclient">WebViewClient</h3>
<pre><code class="language-java">// 拦截页面加载，返回true表示宿主app拦截并处理了该url，否则返回false由当前WebView处理
// 此方法在API24被废弃，不处理POST请求
public boolean shouldOverrideUrlLoading(WebView view, String url) {
    return false;
}

// 拦截页面加载，返回true表示宿主app拦截并处理了该url，否则返回false由当前WebView处理
// 此方法添加于API24，不处理POST请求，可拦截处理子frame的非http请求
@TargetApi(Build.VERSION_CODES.N)
public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
    return shouldOverrideUrlLoading(view, request.getUrl().toString());
}

// 此方法废弃于API21，调用于非UI线程
// 拦截资源请求并返回响应数据，返回null时WebView将继续加载资源
public WebResourceResponse shouldInterceptRequest(WebView view, String url) {
    return null;
}

// 此方法添加于API21，调用于非UI线程
// 拦截资源请求并返回数据，返回null时WebView将继续加载资源
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {
    return shouldInterceptRequest(view, request.getUrl().toString());
}

// 页面(url)开始加载
public void onPageStarted(WebView view, String url, Bitmap favicon) {
}

// 页面(url)完成加载
public void onPageFinished(WebView view, String url) {
}

// 将要加载资源(url)
public void onLoadResource(WebView view, String url) {
}

// 这个回调添加于API23，仅用于主框架的导航
// 通知应用导航到之前页面时，其遗留的WebView内容将不再被绘制。
// 这个回调可以用来决定哪些WebView可见内容能被安全地回收，以确保不显示陈旧的内容
// 它最早被调用，以此保证WebView.onDraw不会绘制任何之前页面的内容，随后绘制背景色或需要加载的新内容。
// 当HTTP响应body已经开始加载并体现在DOM上将在随后的绘制中可见时，这个方法会被调用。
// 这个回调发生在文档加载的早期，因此它的资源(css,和图像)可能不可用。
// 如果需要更细粒度的视图更新，查看 postVisualStateCallback(long, WebView.VisualStateCallback).
// 请注意这上边的所有条件也支持 postVisualStateCallback(long ,WebView.VisualStateCallback)
public void onPageCommitVisible(WebView view, String url) {
}

// 此方法废弃于API23
// 主框架加载资源时出错
public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
}

// 此方法添加于API23
// 加载资源时出错，通常意味着连接不到服务器
// 由于所有资源加载错误都会调用此方法，所以此方法应尽量逻辑简单
@TargetApi(Build.VERSION_CODES.M)
public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) {
    if (request.isForMainFrame()) {
        onReceivedError(view, error.getErrorCode(), error.getDescription().toString(), request.getUrl().toString());
    }
}

// 此方法添加于API23
// 在加载资源(iframe,image,js,css,ajax...)时收到了 HTTP 错误(状态码&gt;=400)
public void onReceivedHttpError(WebView view, WebResourceRequest request, WebResourceResponse errorResponse) {
}


// 是否重新提交表单，默认不重发
public void onFormResubmission(WebView view, Message dontResend, Message resend) {
    dontResend.sendToTarget();
}

// 通知应用可以将当前的url存储在数据库中，意味着当前的访问url已经生效并被记录在内核当中。
// 此方法在网页加载过程中只会被调用一次，网页前进后退并不会回调这个函数。
public void doUpdateVisitedHistory(WebView view, String url, boolean isReload) {
}

// 加载资源时发生了一个SSL错误，应用必需响应(继续请求或取消请求)
// 处理决策可能被缓存用于后续的请求，默认行为是取消请求
public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
    handler.cancel();
}

// 此方法添加于API21，在UI线程被调用
// 处理SSL客户端证书请求，必要的话可显示一个UI来提供KEY。
// 有三种响应方式：proceed()/cancel()/ignore()，默认行为是取消请求
// 如果调用proceed()或cancel()，Webview 将在内存中保存响应结果且对相同的&quot;host:port&quot;不会再次调用 onReceivedClientCertRequest
// 多数情况下，可通过KeyChain.choosePrivateKeyAlias启动一个Activity供用户选择合适的私钥
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
public void onReceivedClientCertRequest(WebView view, ClientCertRequest request) {
    request.cancel();
}

// 处理HTTP认证请求，默认行为是取消请求
public void onReceivedHttpAuthRequest(WebView view, HttpAuthHandler handler, String host, String realm) {
    handler.cancel();
}

// 通知应用有个已授权账号自动登陆了
public void onReceivedLoginRequest(WebView view, String realm, String account, String args) {
}
// 给应用一个机会处理按键事件
// 如果返回true，WebView不处理该事件，否则WebView会一直处理，默认返回false
public boolean shouldOverrideKeyEvent(WebView view, KeyEvent event) {
    return false;
}

// 处理未被WebView消费的按键事件
// WebView总是消费按键事件，除非是系统按键或shouldOverrideKeyEvent返回true
// 此方法在按键事件分派时被异步调用
public void onUnhandledKeyEvent(WebView view, KeyEvent event) {
    super.onUnhandledKeyEvent(view, event);
}

// 通知应用页面缩放系数变化
public void onScaleChanged(WebView view, float oldScale, float newScale) {
} 

</code></pre>
<h3 id="webchromeclient">WebChromeClient</h3>
<pre><code class="language-java">// 获得所有访问历史项目的列表，用于链接着色。
public void getVisitedHistory(ValueCallback&lt;String[]&gt; callback) {
}

// &lt;video /&gt; 控件在未播放时，会展示为一张海报图，HTML中可通过它的'poster'属性来指定。
// 如果未指定'poster'属性，则通过此方法提供一个默认的海报图。
public Bitmap getDefaultVideoPoster() {
    return null;
}

// 当全屏的视频正在缓冲时，此方法返回一个占位视图(比如旋转的菊花)。
public View getVideoLoadingProgressView() {
    return null;
}

// 接收当前页面的加载进度
public void onProgressChanged(WebView view, int newProgress) {
}

// 接收文档标题
public void onReceivedTitle(WebView view, String title) {
}

// 接收图标(favicon)
public void onReceivedIcon(WebView view, Bitmap icon) {
}

// Android中处理Touch Icon的方案
// http://droidyue.com/blog/2015/01/18/deal-with-touch-icon-in-android/index.html
public void onReceivedTouchIconUrl(WebView view, String url, boolean precomposed) {
}

// 通知应用当前页进入了全屏模式，此时应用必须显示一个包含网页内容的自定义View
public void onShowCustomView(View view, CustomViewCallback callback) {
}

// 通知应用当前页退出了全屏模式，此时应用必须隐藏之前显示的自定义View
public void onHideCustomView() {
}


// 显示一个alert对话框
public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
    return false;
}

// 显示一个confirm对话框
public boolean onJsConfirm(WebView view, String url, String message, JsResult result) {
    return false;
}

// 显示一个prompt对话框
public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {
    return false;
}

// 显示一个对话框让用户选择是否离开当前页面
public boolean onJsBeforeUnload(WebView view, String url, String message, JsResult result) {
    return false;
}


// 指定源的网页内容在没有设置权限状态下尝试使用地理位置API。
// 从API24开始，此方法只为安全的源(https)调用，非安全的源会被自动拒绝
public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) {
}

// 当前一个调用 onGeolocationPermissionsShowPrompt() 取消时，隐藏相关的UI。
public void onGeolocationPermissionsHidePrompt() {
}

// 通知应用打开新窗口
public boolean onCreateWindow(WebView view, boolean isDialog, boolean isUserGesture, Message resultMsg) {
    return false;
}

// 通知应用关闭窗口
public void onCloseWindow(WebView window) {
}

// 请求获取取焦点
public void onRequestFocus(WebView view) {
}

// 通知应用网页内容申请访问指定资源的权限(该权限未被授权或拒绝)
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
public void onPermissionRequest(PermissionRequest request) {
    request.deny();
}

// 通知应用权限的申请被取消，隐藏相关的UI。
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
public void onPermissionRequestCanceled(PermissionRequest request) {
}

// 为'&lt;input type=&quot;file&quot; /&gt;'显示文件选择器，返回false使用默认处理
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, FileChooserParams fileChooserParams) {
    return false;
}

// 接收JavaScript控制台消息
public boolean onConsoleMessage(ConsoleMessage consoleMessage) {
    return false;
} 

</code></pre>
<h2 id="webview_2">Webview 加载优化</h2>
<ul>
<li>使用本地资源替代</li>
</ul>
<p>可以 将一些资源文件放在本地的 asset s目录, 然后重 写WebViewClient 的 <code>shouldInterceptRequest</code> 方法，对访问地址进行拦截，当 url 地址命中本地配置的url时，使用本地资源替代，否则就使用网络上的资源。</p>
<pre><code class="language-java">mWebview.setWebViewClient(new WebViewClient() {   
     // 设置不用系统浏览器打开,
    @Override    
    public boolean shouldOverrideUrlLoading(WebView view, String url) {      
        view.loadUrl(url);     
        return true;    
    }   
         
    @Override    
    public WebResourceResponse shouldInterceptRequest(WebView view, String url) {      // 如果命中本地资源, 使用本地资源替代      
        if (mDataHelper.hasLocalResource(url)){         
             WebResourceResponse response = mDataHelper.getReplacedWebResourceResponse(getApplicationContext(), url);          
            if (response != null) {              
                return response;
            }      
        }      
        return super.shouldInterceptRequest(view, url);    
    }   

    @TargetApi(VERSION_CODES.LOLLIPOP)@Override    
    public WebResourceResponse shouldInterceptRequest(WebView view,WebResourceRequest request) {      
        String url = request.getUrl().toString();      
        if (mDataHelper.hasLocalResource(url)) {         
            WebResourceResponse response =  mDataHelper.getReplacedWebResourceResponse(getApplicationContext(), url);          
            if (response != null) {              
                return response;          
            }      
        }      
        return super.shouldInterceptRequest(view, request);    
    }
}); 
</code></pre>
<ul>
<li>
<p>WebView初始化慢，可以在初始化同时先请求数据，让后端和网络不要闲着。</p>
</li>
<li>
<p>后端处理慢，可以让服务器分trunk输出，在后端计算的同时前端也加载网络静态资源。</p>
</li>
<li>
<p>脚本执行慢，就让脚本在最后运行，不阻塞页面解析。</p>
</li>
<li>
<p>同时，合理的预加载、预缓存可以让加载速度的瓶颈更小。</p>
</li>
<li>
<p>WebView初始化慢，就随时初始化好一个WebView待用。</p>
</li>
<li>
<p>DNS和链接慢，想办法复用客户端使用的域名和链接。</p>
</li>
<li>
<p>脚本执行慢，可以把框架代码拆分出来，在请求页面之前就执行好。</p>
</li>
</ul>
<p><img alt="" src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/9a2f8beb.png" /></p>
<h2 id="_43">内存泄漏</h2>
<p>直接 new WebView 并传入 application context 代替在 XML 里面声明以防止 activity 引用被滥用，能解决90+%的 WebView 内存泄漏。</p>
<pre><code class="language-java">vWeb =  new WebView(getContext().getApplicationContext());
container.addView(vWeb);
</code></pre>
<p>销毁 WebView</p>
<pre><code class="language-java">if (vWeb != null) {
    vWeb.setWebViewClient(null);
    vWeb.setWebChromeClient(null);
    vWeb.loadDataWithBaseURL(null, &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
    vWeb.clearHistory();

    ((ViewGroup) vWeb.getParent()).removeView(vWeb);
    vWeb.destroy();
    vWeb = null;
} 
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js" defer></script>
        <script src="../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
